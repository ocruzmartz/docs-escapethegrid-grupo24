{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Escape the Grid: The Magic Box","text":""},{"location":"#descripcion-general-del-juego","title":"Descripci\u00f3n General del Juego","text":"<p>\u00a1Bienvenido a Escape the Grid! Un desafiante puzzle 2D estrat\u00e9gico donde cada movimiento cuenta y cada decisi\u00f3n es crucial. Atrapado en un laberinto de tri\u00e1ngulos interconectados, deber\u00e1s trazar tu camino hacia la libertad planificando cuidadosamente cada paso.</p> <p>Lo que hace \u00fanico a Escape the Grid no es solo su distintiva cuadr\u00edcula triangular, sino sus mec\u00e1nicas que cambian constantemente el tablero. La salida permanece invisible ante tus ojos hasta que logres activar la misteriosa \"Caja M\u00e1gica\" pasando sobre las celdas amarillas en la secuencia correcta, la cual deber\u00e1s descubrir por ti mismo. Pero cuidado: mientras exploras, ciertas celdas se transforman en muros impenetrables conforme avanzas, bloqueando posibles rutas de escape.</p> <p>Comenzar\u00e1s con 1000 puntos, pero cada vez que retrocedas por un camino ya recorrido, tu puntuaci\u00f3n disminuir\u00e1. \u00bfTienes la astucia para descifrar el patr\u00f3n y encontrar la ruta perfecta hacia la libertad? \u00bfO quedar\u00e1s atrapado para siempre en este laberinto cambiante?</p> <p></p>"},{"location":"#caracteristicas-principales","title":"Caracter\u00edsticas Principales","text":""},{"location":"#mecanicas-del-juego","title":"Mec\u00e1nicas del Juego","text":"<ul> <li>La Caja M\u00e1gica: Descubre en el orden correcto pasando sobre las celdas amarillas. Solo completando esta misteriosa secuencia podr\u00e1s hacer visible la salida.</li> <li>Salida Oculta: La meta permanece invisible hasta completar la secuencia correcta.</li> <li> <p>Paredes Temporizadas: Las celdas azules se transforman en muros innacesibles despu\u00e9s de 30 turnos.</p> </li> <li> <p>Triangulaci\u00f3n Din\u00e1mica: Navega por un mapa compuesto enteramente de celdas triangulares interconectadas.</p> </li> </ul>"},{"location":"#sistema-de-puntuacion","title":"Sistema de Puntuaci\u00f3n","text":"<ul> <li>Puntos Iniciales: 1000 puntos al comenzar.</li> <li>Penalizaci\u00f3n por Retroceso: -50 puntos cada vez que revisitas una celda.</li> <li>Condici\u00f3n de Derrota: Quedarte sin puntos o sin movimientos posibles.</li> </ul>"},{"location":"#interfaz-y-controles","title":"Interfaz y Controles","text":"<ul> <li>Control por Rat\u00f3n: Interacci\u00f3n completa mediante clics (clic izquierdo).</li> <li>Panel Lateral Derecho: Muestra puntuaci\u00f3n actual, turnos restantes y pr\u00f3ximo objetivo. Adem\u00e1s de dos botones para reiniciar el juego o resolver autom\u00e1ticamente.</li> <li>Panel Lateral Izquierdo: Muestra el laberinto de tri\u00e1ngulos donde se desarrolla la acci\u00f3n.</li> <li>Visualizaci\u00f3n de Estado: Feedback claro sobre victoria, derrota y progreso.</li> </ul>"},{"location":"#herramientas-avanzadas","title":"Herramientas Avanzadas","text":"<ul> <li>Algoritmo de Resoluci\u00f3n: Encuentra y muestra la ruta \u00f3ptima hacia la meta (usando el algoritmo A*).</li> <li>Reproducci\u00f3n Autom\u00e1tica: Observa la soluci\u00f3n ejecutada paso a paso.</li> <li>Detecci\u00f3n de Estado Final: El juego reconoce autom\u00e1ticamente cuando te has quedado sin opciones.</li> </ul>"},{"location":"#informacion-adicional","title":"Informaci\u00f3n Adicional","text":"<p>En la secci\u00f3n Gu\u00eda del Usuario encontrar\u00e1s todo lo necesario para comenzar a jugar, desde la instalaci\u00f3n hasta los controles y mec\u00e1nicas del juego. En la secci\u00f3n Reporte T\u00e9cnico encontrar\u00e1s detalles sobre los algoritmos implementados y la biblioteca gr\u00e1fica utilizada. Aqu\u00ed tienes algunos accesos r\u00e1pidos:</p> <ul> <li> <p>Para m\u00e1s detalles sobre el algoritmo de resoluci\u00f3n y c\u00f3mo se implementa, revisa la secci\u00f3n de Algoritmos Implementados.</p> </li> <li> <p>Para m\u00e1s detalles sobre los controles y como jugar, revisa la secci\u00f3n de Controles y Jugabilidad.</p> </li> <li> <p>Para m\u00e1s detalles sobre como configurar el entorno y compilar el juego, revisa la secci\u00f3n de Instrucciones de Compilaci\u00f3n.</p> </li> <li> <p>Para m\u00e1s detalles sobre c\u00f3mo crear mapas personalizados, consulta la secci\u00f3n de Mapas Personalizados.</p> </li> <li> <p>Para ver todas las mec\u00e1nicas del juego en acci\u00f3n, revisa la secci\u00f3n de Gu\u00eda Visual.</p> </li> </ul>"},{"location":"technical_report/algorithms/","title":"Algoritmo A* y su Implementaci\u00f3n","text":"<p>La base algor\u00edtmica del proyecto \"Escape the Grid\" se fundamenta en dos componentes principales: la representaci\u00f3n del mapa del juego como un grafo y un sistema de b\u00fasqueda de caminos inteligente. Este sistema es capaz de adaptarse a las reglas din\u00e1micas del puzzle en la variante \u201cCaja M\u00e1gica\u201d para su resoluci\u00f3n autom\u00e1tica.</p> <p>Para ello, se ha dise\u00f1ado un algoritmo capaz de resolver un puzzle complejo con las siguientes caracter\u00edsticas:</p> <ul> <li>Un entorno no est\u00e1ndar basado en una malla de tri\u00e1ngulos.</li> <li>M\u00faltiples objetivos secuenciales que deben ser alcanzados en un orden predefinido (la mec\u00e1nica de la \"Caja M\u00e1gica\").</li> <li>Restricciones din\u00e1micas, donde el estado del mapa cambia con el tiempo (hay celdas que inician accesibles, pero al haber pasado \\(N\\) turnos, se convierten en paredes).</li> </ul> <p>Para resolver esta problem\u00e1tica, se opt\u00f3 por una arquitectura de software modular y una soluci\u00f3n algor\u00edtmica por capas, cuyo componente central es el algoritmo de b\u00fasqueda de caminos A* (A-Estrella).</p>"},{"location":"technical_report/algorithms/#fundamentos-teoricos-del-algoritmo-de-busqueda-a","title":"Fundamentos Te\u00f3ricos del Algoritmo de B\u00fasqueda A*","text":"<p>A* es un algoritmo de b\u00fasqueda informado, considerado el est\u00e1ndar en la industria de los videojuegos para encontrar el camino de menor costo en un grafo. Su principal ventaja sobre otros algoritmos es su balance entre optimalidad y rendimiento.</p> <ul> <li> <p>A diferencia del Algoritmo de Dijkstra, que explora de forma expansiva en todas las direcciones y puede ser lento, A* utiliza una heur\u00edstica para enfocar su b\u00fasqueda hacia el objetivo.</p> </li> <li> <p>A diferencia de algoritmos voraces como Greedy Best-First Search, que son r\u00e1pidos pero no garantizan encontrar el camino m\u00e1s corto, A* s\u00ed garantiza la ruta \u00f3ptima si su heur\u00edstica es admisible.</p> </li> </ul> <p></p>"},{"location":"technical_report/algorithms/#la-ecuacion-heuristica","title":"La Ecuaci\u00f3n Heur\u00edstica","text":"<p>El poder de A* reside en su funci\u00f3n de evaluaci\u00f3n, que utiliza para determinar la \"promesa\" de cada nodo \\(n\\) en la frontera de la b\u00fasqueda:</p> \\[f(n) = g(n) + h(n)\\] <p>Donde los t\u00e9rminos se definen formalmente como:</p> <ul> <li> <p>\\(g(n)\\): Es el costo exacto y conocido del camino recorrido desde el nodo de inicio hasta el nodo \\(n\\).</p> </li> <li> <p>\\(h(n)\\): Es el costo heur\u00edstico, una estimaci\u00f3n o \"suposici\u00f3n informada\" del costo para llegar desde el nodo \\(n\\) hasta el nodo objetivo final.</p> </li> </ul> <p></p> <p>Para que A* garantice la soluci\u00f3n \u00f3ptima, la funci\u00f3n heur\u00edstica \\(h(n)\\) debe ser admisible. Una heur\u00edstica es admisible si su estimaci\u00f3n es siempre optimista, es decir, nunca sobreestima el costo real para alcanzar el objetivo (\\(h(n) \u2264 costo\\_real\\)).</p>"},{"location":"technical_report/algorithms/#el-proceso-algoritmico-y-sus-estructuras","title":"El Proceso Algor\u00edtmico y sus Estructuras","text":"<p>El algoritmo A* opera manteniendo dos listas conceptuales de nodos:</p> <ol> <li> <p>Open Set: Una lista de nodos que ya han sido descubiertos, pero cuyos vecinos a\u00fan no han sido completamente explorados. El algoritmo siempre extrae de esta lista el nodo con el menor costo \\(f(n)\\).</p> </li> <li> <p>Closed Set: Una lista de nodos que ya han sido completamente explorados y no necesitan ser revisados de nuevo, a menos que se encuentre una ruta hacia ellos que sea estrictamente mejor.</p> </li> </ol>"},{"location":"technical_report/algorithms/#arquitectura-de-software-para-la-resolucion-de-rutas","title":"Arquitectura de Software para la Resoluci\u00f3n de Rutas","text":"<p>Con la teor\u00eda establecida, se dise\u00f1\u00f3 una arquitectura de clases en C++ para aplicar estos conceptos al problema espec\u00edfico del juego.</p> <ul> <li> <p><code>GridModel</code>: Representa el grafo. Contiene el <code>std::vector</code> de todos los <code>TrianguloNode</code> y la l\u00f3gica para establecer sus conexiones (<code>vecinos</code>), as\u00ed como para interactuar con el mapa (ej. <code>updateTimedWalls</code>).</p> </li> <li> <p><code>GameState</code>: Encapsula las reglas de la partida. Mantiene el estado del jugador (turnos, puntaje) y el progreso en la secuencia de la \"Caja M\u00e1gica\". Es responsable de gestionar adecuadamente las restricciones din\u00e1micas del juego.</p> </li> <li> <p><code>Solver</code>: Contiene la implementaci\u00f3n de la inteligencia artificial. Se dise\u00f1\u00f3 para ser un \"servicio\" que lee el estado del <code>GridModel</code> y <code>GameState</code> (a trav\u00e9s de referencias constantes para asegurar que no los modifique) y devuelve una soluci\u00f3n.</p> </li> <li> <p><code>PathfindingNode</code>: Estructura auxiliar que almacena el estado de un nodo durante una b\u00fasqueda.</p> </li> </ul> <pre><code>// Archivo: PathfindingNode.hpp\nstruct PathfindingNode {\n    int id;       // ID del TrianguloNode\n    int parentId; // ID del nodo padre para reconstruir el camino\n    float gCost;  // Costo desde el inicio (turnos)\n    float hCost;  // Heur\u00edstica hasta el objetivo\n    float fCost;  // Costo total (gCost + hCost)\n};\n</code></pre>"},{"location":"technical_report/algorithms/#implementacion-detallada","title":"Implementaci\u00f3n Detallada","text":""},{"location":"technical_report/algorithms/#estructuras-de-datos-del-solver","title":"Estructuras de Datos del Solver","text":"<p>La eficiencia del algoritmo depende de sus estructuras de datos.</p> <ul> <li>Open Set (<code>std::priority_queue</code>): La \"frontera\" se implement\u00f3 con <code>std::priority_queue</code>. Esta estructura es un max-heap por defecto, pero A* necesita un min-heap (extraer el menor <code>fCost</code>). Se implement\u00f3 un comparador personalizado para invertir su comportamiento. Esto garantiza la extracci\u00f3n del mejor nodo en tiempo \\(O(logN)\\).</li> </ul> <pre><code>// Archivo: Solver.cpp\nstruct ComparePathfindingNode {\n    bool operator()(const PathfindingNode&amp; a, const PathfindingNode&amp; b) const {\n        return a.fCost &gt; b.fCost;\n    }\n};\n</code></pre> <ul> <li>Closed Set (Optimizaci\u00f3n): En lugar de un <code>std::set</code>, se us\u00f3 un vector <code>gCosts</code> inicializado a infinito. Un nodo solo se re-eval\u00faa si se encuentra una nueva ruta con un <code>gCost</code> estrictamente menor, evitando la sobrecarga de una segunda estructura de datos.</li> </ul>"},{"location":"technical_report/algorithms/#findpath-el-nucleo-de-a","title":"<code>findPath</code>: El N\u00facleo de A*","text":"<p>Esta funci\u00f3n privada en <code>Solver</code> es la implementaci\u00f3n directa del pseudoc\u00f3digo de A*.</p> <ul> <li> <p>Adaptaci\u00f3n de Costos: El valor de \\(g(n)\\) se implement\u00f3 como el n\u00famero de turnos, asignando un costo de <code>1</code> a cada movimiento. La heur\u00edstica \\(h(n)\\) se implement\u00f3 con la distancia euclidiana, que es admisible para un mapa 2D.</p> </li> <li> <p>Manejo de Reglas Din\u00e1micas: La inteligencia del algoritmo reside en la validaci\u00f3n de vecinos Antes de calcular el <code>tentative_gScore</code> de un vecino, se comprueba si es un obst\u00e1culo. Esta comprobaci\u00f3n no solo mira si es una <code>PARED</code> o <code>VACIO</code>, sino que utiliza el par\u00e1metro <code>turnosActuales</code> para calcular un <code>turnoFuturo</code> y determinar si una celda <code>TIMED_WALL</code> estar\u00eda bloqueada en ese momento.</p> </li> </ul> <pre><code>// Archivo: Solver.cpp\nfloat tentativeGCost = gCosts[currentNode.id] + 1;\nint turnoFuturo = turnosActuales + static_cast&lt;int&gt;(tentativeGCost);\n\nif (neighborNode.tipo == TipoCelda::PARED ||\n    neighborNode.tipo == TipoCelda::VACIO ||\n    (neighborNode.tipo == TipoCelda::TIMED_WALL &amp;&amp; turnoFuturo &gt;= TURN_LIMIT)) {\n    continue;\n}\n</code></pre>"},{"location":"technical_report/algorithms/#solve-el-orquestador-estrategico","title":"<code>solve</code>: El Orquestador Estrat\u00e9gico","text":"<p>La funci\u00f3n p\u00fablica <code>solve</code> implementa la estrategia de alto nivel para resolver la \"Caja M\u00e1gica\", que es la mec\u00e1nica principal de esta variante de Escape the Grid.</p> <ul> <li> <p>Planificaci\u00f3n Din\u00e1mica: Consulta el <code>GameState</code> para determinar los objetivos que a\u00fan faltan en la secuencia.</p> </li> <li> <p>Ejecuci\u00f3n Secuencial: Llama a <code>findPath</code> para cada tramo del viaje (ej: de la posici\u00f3n actual al \u00edtem <code>2</code>). El costo en turnos de cada tramo se acumula y se pasa como par\u00e1metro a la siguiente llamada, asegurando que toda la planificaci\u00f3n respete el l\u00edmite de turnos global.</p> </li> </ul>"},{"location":"technical_report/algorithms/#maincpp-la-logica-de-interfaz-de-superayuda","title":"<code>main.cpp</code>: La L\u00f3gica de Interfaz de \"Superayuda\"","text":"<p>La capa final de inteligencia reside en la l\u00f3gica del bot\u00f3n \"Resolver\" dentro de <code>main.cpp</code>.</p> <ol> <li> <p>Intento Contextual: Primero invoca a <code>solver-&gt;solve()</code> desde la posici\u00f3n y turno actuales del jugador para encontrar una soluci\u00f3n inmediata en dicha situaci\u00f3n.</p> </li> <li> <p>Intento de Base: Si el intento anterior falla (por estar atrapado o por falta de turnos), el sistema infiere un estado irresoluble. En lugar de rendirse o presentar un error de \"imposibilidad\", crea una instancia temporal y limpia de <code>GridModel</code> y <code>GameState</code>, y vuelve a llamar al <code>solver</code> para calcular la soluci\u00f3n \u00f3ptima global desde el inicio.</p> </li> <li> <p>Presentaci\u00f3n: El sistema reinicia el tablero de juego principal y ejecuta un \"autoplay\" para mostrar esta soluci\u00f3n \u00f3ptima, sirviendo como una gu\u00eda y soluci\u00f3n autom\u00e1tica para el jugador desde el inicio del juego.</p> </li> </ol>"},{"location":"technical_report/algorithms/#analisis-de-complejidad","title":"An\u00e1lisis de Complejidad","text":"<ul> <li> <p>Complejidad Espacial (Memoria): Es del orden de \\(O(N)\\), donde \\(N\\) es el n\u00famero de nodos, debido a que las estructuras de datos (<code>nodosDelGrid</code>, <code>gCosts</code>, <code>parentMap</code>) crecen linealmente con el mapa.</p> </li> <li> <p>Complejidad Temporal (Tiempo): En el peor de los casos, la complejidad es de \\(O(NlogN)\\). El factor \\(logN\\) proviene de las operaciones de inserci\u00f3n y extracci\u00f3n en la <code>std::priority_queue</code>.</p> </li> </ul> <p>Note</p> <p>Se tom\u00f3 como referencia la informaci\u00f3n presentada en los art\u00edculos de Amit Patel y Red Blob Games, referentes en el campo de la b\u00fasqueda de caminos y algoritmos con A*(A-Estrella). Adem\u00e1s de El Algoritmo A*: Gu\u00eda completa de DataCamp, que ofrece una explicaci\u00f3n detallada y ejemplos pr\u00e1cticos de implementaci\u00f3n.</p>"},{"location":"technical_report/development_challenges/","title":"Desaf\u00edos de Desarrollo y Soluciones Implementadas","text":"<p>Durante el desarrollo de \"Escape the Grid\", surgieron varios desaf\u00edos t\u00e9cnicos que requirieron soluciones espec\u00edficas y un dise\u00f1o cuidadoso. A continuaci\u00f3n, se detallan los problemas m\u00e1s significativos y c\u00f3mo fueron resueltos a nivel de c\u00f3digo y arquitectura.</p>"},{"location":"technical_report/development_challenges/#1-a-con-restricciones-dinamicas-paredes-temporizadas","title":"1. A* con Restricciones Din\u00e1micas (Paredes Temporizadas)","text":"<ul> <li> <p>El Desaf\u00edo: El algoritmo A est\u00e1ndar est\u00e1 dise\u00f1ado para operar sobre un grafo est\u00e1tico, donde los costos y la transitabilidad de los nodos no cambian. La mec\u00e1nica de los <code>TIMED_WALL</code> (<code>T</code>) romp\u00eda esta premisa: una celda pod\u00eda ser transitable al inicio de la b\u00fasqueda, pero convertirse en un muro intransitable en un futuro, dependiendo del n\u00famero de turnos del camino encontrado. Un A simple no podr\u00eda prever este cambio, llevando a la generaci\u00f3n de rutas inv\u00e1lidas.</p> </li> <li> <p>La Soluci\u00f3n: La soluci\u00f3n fue hacer que el algoritmo A* fuera \"consciente del futuro\". En lugar de solo verificar el estado actual de un nodo vecino, la implementaci\u00f3n en <code>Solver.cpp</code> calcula el costo tentativo en turnos para llegar a ese vecino y lo suma a los turnos ya transcurridos. Este <code>turnoFuturo</code> es el que se utiliza para validar si una pared temporizada estar\u00eda activa en el momento de llegar a ella.</p> <p><pre><code>// filepath: c:\\Users\\mosca\\Escritorio\\Ciclo 01-25\\TSC\\test_repo\\tsc-project-game\\src\\Solver.cpp\n// ...existing code...\n    for (int neighborId : gridNode.vecinos)\n    {\n        const auto &amp;neighborNode = m_grid.getNodo(neighborId);\n        float tentativeGCost = gCosts[currentNode.id] + 1;\n        int turnoFuturo = turnosActuales + static_cast&lt;int&gt;(tentativeGCost);\n\n        if (neighborNode.tipo == TipoCelda::PARED || \n            neighborNode.tipo == TipoCelda::VACIO || \n           (neighborNode.tipo == TipoCelda::TIMED_WALL &amp;&amp; turnoFuturo &gt;= TURN_LIMIT))\n        {\n            continue;\n        }\n// ...existing code...\n</code></pre> Esta comprobaci\u00f3n asegura que A* solo considere caminos que sean v\u00e1lidos durante toda su trayectoria, respetando el l\u00edmite de <code>TURN_LIMIT</code> definido en <code>config.hpp</code>.</p> </li> </ul>"},{"location":"technical_report/development_challenges/#2-resolucion-de-multiples-objetivos-secuenciales-la-caja-magica","title":"2. Resoluci\u00f3n de M\u00faltiples Objetivos Secuenciales (La \"Caja M\u00e1gica\")","text":"<ul> <li> <p>El Desaf\u00edo: El algoritmo A est\u00e1 dise\u00f1ado para encontrar la ruta \u00f3ptima entre un \u00fanico punto de inicio y un \u00fanico punto de fin. El modo de juego \"Caja M\u00e1gica\" requer\u00eda una soluci\u00f3n para un problema de m\u00faltiples destinos secuenciales (Inicio -&gt; \u00cdtem 1 -&gt; \u00cdtem 2 -&gt; \u00cdtem 3 -&gt; Final). Una sola ejecuci\u00f3n de A era insuficiente.</p> </li> <li> <p>La Soluci\u00f3n: Se implement\u00f3 una capa de orquestaci\u00f3n estrat\u00e9gica en la funci\u00f3n <code>Solver::solve</code>. Esta funci\u00f3n act\u00faa como un planificador de alto nivel que utiliza A* como una subrutina.</p> <ol> <li>Consulta el <code>GameState</code> para determinar la secuencia de objetivos restantes.</li> <li>Ejecuta un bucle que llama a <code>findPath</code> para cada tramo del viaje (ej. desde la posici\u00f3n actual hasta el \u00cdtem '1').</li> <li>Acumula los turnos gastados en cada tramo y los pasa como par\u00e1metro (<code>turnosTranscurridos</code>) a la siguiente llamada de <code>findPath</code>.</li> <li>Concatena los sub-caminos resultantes para formar una \u00fanica ruta completa.</li> </ol> <p><pre><code>// filepath: c:\\Users\\mosca\\Escritorio\\Ciclo 01-25\\TSC\\test_repo\\tsc-project-game\\src\\Solver.cpp\n// ...existing code...\nfor (char finChar : waypoints_restantes)\n{\n    // ... encontrar el nodo objetivo ...\n    std::vector&lt;int&gt; subCamino = findPath(nodoDePartidaActual, *nodoFinOpt, turnosTranscurridos);\n\n    if (subCamino.empty())\n    {\n        // ... manejar fallo ...\n        return {};\n    }\n\n    turnosTranscurridos += subCamino.size() - 1;\n    caminoCompleto.insert(caminoCompleto.end(), subCamino.begin() + 1, subCamino.end());\n    nodoDePartidaActual = *nodoFinOpt;\n}\n// ...existing code...\n</code></pre> Este enfoque modular permiti\u00f3 resolver un problema complejo descomponi\u00e9ndolo en una serie de b\u00fasquedas A* m\u00e1s simples, asegurando que la soluci\u00f3n global fuera coherente con las reglas del juego.</p> </li> </ul>"},{"location":"technical_report/development_challenges/#3-la-logica-de-superayuda-y-el-manejo-de-estados-irresolubles","title":"3. La L\u00f3gica de \"Superayuda\" y el Manejo de Estados Irresolubles","text":"<ul> <li> <p>El Desaf\u00edo: \u00bfQu\u00e9 deber\u00eda ocurrir si el jugador se encierra a s\u00ed mismo y luego presiona el bot\u00f3n \"Resolver\"? Una llamada simple al <code>solver</code> desde la posici\u00f3n actual del jugador fallar\u00eda, resultando en una mala experiencia de usuario al no recibir ninguna ayuda.</p> </li> <li> <p>La Soluci\u00f3n: Se implement\u00f3 una l\u00f3gica de \"superayuda\" con un mecanismo de repliegue (fallback) en <code>main.cpp</code>.</p> <ol> <li>Intento Contextual: Al presionar \"Resolver\", el juego primero intenta encontrar una soluci\u00f3n desde la posici\u00f3n y turno actuales del jugador.</li> <li>Repliegue a Soluci\u00f3n \u00d3ptima: Si el intento anterior falla (es decir, <code>rutaSolucion</code> est\u00e1 vac\u00eda), el sistema no se rinde. En su lugar, crea una instancia temporal y limpia de <code>GridModel</code> y <code>GameState</code> para simular un reinicio. Llama al <code>solver</code> sobre este estado limpio para calcular la soluci\u00f3n \u00f3ptima global desde el inicio del juego.</li> <li>Presentaci\u00f3n: Finalmente, el juego principal se resetea y se utiliza la ruta \u00f3ptima encontrada para iniciar el \"autoplay\", mostrando al jugador la mejor soluci\u00f3n posible desde el principio.</li> </ol> <p><pre><code>// filepath: c:\\Users\\mosca\\Escritorio\\Ciclo 01-25\\TSC\\test_repo\\tsc-project-game\\src\\main.cpp\n// ...existing code...\n                    rutaSolucion = solver-&gt;solve(jugador.getNodoActualId());\n\n                    if (rutaSolucion.empty()) {\n                        infoText.setString(\"No hay solucion desde aqui. Mostrando solucion optima...\");\n                        // --- L\u00d3GICA CORREGIDA: Usamos un grid temporal para el c\u00e1lculo ---\n                        GridModel gridOptimo;\n                        gridOptimo.cargarDesdeArchivo(\"mapa.txt\", window);\n                        GameState estadoInicial;\n                        Solver solverDesdeInicio(gridOptimo, estadoInicial);\n\n                        std::vector&lt;int&gt; rutaOptima;\n                        if(const auto startNodeId = gridOptimo.findStartNodeId()) {\n                            rutaOptima = solverDesdeInicio.solve(*startNodeId);\n                        }\n                        if (!rutaOptima.empty()) {\n                            setupGame(); // Resetea el juego a un estado limpio\n                            rutaSolucion = rutaOptima; // Asignamos la ruta \u00f3ptima encontrada\n                        }\n                    }\n// ...existing code...\n</code></pre> Esta soluci\u00f3n robusta mejora dr\u00e1sticamente la experiencia de usuario, garantizando que el bot\u00f3n \"Resolver\" siempre ofrezca una respuesta \u00fatil.</p> </li> </ul>"},{"location":"technical_report/graphics_lib/","title":"Biblioteca Gr\u00e1fica y Manual de Uso","text":"<p>La creaci\u00f3n de una aplicaci\u00f3n gr\u00e1fica interactiva en C++ requiere dos componentes fundamentales: una biblioteca que gestione los gr\u00e1ficos y un sistema que construya el proyecto. Para \"Escape the Grid\", se seleccion\u00f3 la biblioteca SFML y se gestion\u00f3 a trav\u00e9s del sistema de construcci\u00f3n CMake.</p>"},{"location":"technical_report/graphics_lib/#proceso-de-investigacion-y-seleccion-de-la-biblioteca-grafica-sfml","title":"Proceso de Investigaci\u00f3n y Selecci\u00f3n de la Biblioteca Gr\u00e1fica: SFML","text":"<p>Como parte de los requisitos del proyecto, se realiz\u00f3 una investigaci\u00f3n de las alternativas disponibles para el desarrollo de interfaces gr\u00e1ficas (como Qt, ImGui, SDL2, Raylib, etc.) en C++. El objetivo era encontrar una herramienta que ofreciera un balance \u00f3ptimo entre rendimiento, facilidad de uso, control y compatibilidad con un enfoque de desarrollo moderno orientado a objetos.</p>"},{"location":"technical_report/graphics_lib/#alternativas-consideradas","title":"Alternativas Consideradas","text":"<ul> <li> <p>SDL2: La primera opci\u00f3n considerada fue SDL2, una biblioteca de bajo nivel muy robusta y multiplataforma, excelente para juegos. Su API es bastante completa y est\u00e1 basada en C. Integrarla en un proyecto C++ orientado a objetos como el nuestro habr\u00eda requerido la creaci\u00f3n de \"wrappers\" o clases envoltorio para mantener un dise\u00f1o limpio, a\u00f1adiendo una capa de complejidad adicional que podr\u00eda haber complicado el desarrollo.</p> </li> <li> <p>ImGui: Antes de llegar a SFML, se consider\u00f3 ImGui. Es una biblioteca de interfaz gr\u00e1fica bastante completa, pero con un prop\u00f3sito diferente. Es una GUI de \"modo inmediato\" dise\u00f1ada para crear herramientas de desarrollo y depuraci\u00f3n sobre un motor gr\u00e1fico existente. Como tal, no es una biblioteca de renderizado por s\u00ed misma, por lo que habr\u00edamos necesitado igualmente SFML o SDL2 para dibujar el juego principal.</p> </li> </ul>"},{"location":"technical_report/graphics_lib/#justificacion-de-la-seleccion-de-sfml","title":"Justificaci\u00f3n de la Selecci\u00f3n de SFML","text":"<p>Tras evaluar las alternativas, se seleccion\u00f3 SFML por ser la opci\u00f3n que ofrec\u00eda el mejor equilibrio para los objetivos del proyecto y por su facilidad de integraci\u00f3n con CMake. Las razones espec\u00edficas incluyen:</p> <ul> <li> <p>API Moderna y Orientada a Objetos: SFML proporciona una interfaz de C++ nativa y limpia. Clases como <code>sf::RenderWindow</code>, <code>sf::RectangleShape</code> y <code>sf::Text</code> son intuitivas y permitieron un desarrollo r\u00e1pido y un c\u00f3digo m\u00e1s legible y mantenible.</p> </li> <li> <p>Modularidad: La biblioteca est\u00e1 dividida en m\u00f3dulos (System, Window, Graphics, Audio, Network). Esto permiti\u00f3 enlazar \u00fanicamente los componentes necesarios para nuestro proyecto (Graphics, Window, System), manteniendo las dependencias al m\u00ednimo, cumpliendo con el requisito de \"Modularidad\" del proyecto.</p> </li> <li> <p>Rendimiento con Aceleraci\u00f3n por Hardware: SFML utiliza OpenGL de forma interna para el renderizado, lo que garantiza que todas las operaciones de dibujado sean eficientes y aceleradas por la GPU sin necesidad de gestionar directamente la complejidad de una API gr\u00e1fica de bajo nivel.</p> </li> <li> <p>Facilidad de Uso: Es ideal para proyectos 2D, ya que tareas como cargar una fuente o dibujar un pol\u00edgono se realizan con muy pocas l\u00edneas de c\u00f3digo.</p> </li> </ul>"},{"location":"technical_report/graphics_lib/#integracion-con-el-sistema-de-construccion-cmake","title":"Integraci\u00f3n con el Sistema de Construcci\u00f3n CMake","text":"<p>CMake es una herramienta que automatiza el proceso de compilaci\u00f3n. No compila el c\u00f3digo directamente, sino que utiliza un archivo de configuraci\u00f3n (<code>CMakeLists.txt</code>) para generar los archivos de proyecto nativos para un entorno espec\u00edfico (por ejemplo, una soluci\u00f3n de Visual Studio en Windows o un Makefile en Linux).</p> <p>Para asegurar este proceso de compilaci\u00f3n robusto, multiplataforma y mantenible, es que se utiliz\u00f3 CMake, siguiendo la metodolog\u00eda recomendada por la propia documentaci\u00f3n de SFML (SFML with the CMake Project Template). En lugar de enlazar manualmente las librer\u00edas, se aprovech\u00f3 la capacidad de CMake para automatizar este proceso.</p> <p>En la ra\u00edz del proyecto se encuentra el archivo <code>CMakeLists.txt</code> que contiene dos comandos cruciales para esta integraci\u00f3n:</p> <ol> <li> <p><code>find_package(SFML 3.0 REQUIRED COMPONENTS ...)</code>: Este comando le pide a CMake que busque en el sistema una instalaci\u00f3n de SFML que cumpla con los requisitos. CMake se encarga de localizar las cabeceras (.hpp) y las librer\u00edas (.lib/.dll) necesarias.</p> </li> <li> <p><code>target_link_libraries(game PRIVATE SFML::...)</code>: Una vez que CMake ha encontrado SFML, este comando le dice al enlazador (linker) que conecte nuestro ejecutable (game) con los m\u00f3dulos de SFML correspondientes. CMake se encarga de resolver las rutas y dependencias correctas para el sistema operativo en el que se est\u00e9 compilando.</p> </li> </ol> <p>Este enfoque automatiza la gesti\u00f3n de dependencias, haciendo que el proyecto sea f\u00e1cil de compilar en diferentes m\u00e1quinas y reduciendo la posibilidad de errores.</p>"},{"location":"technical_report/graphics_lib/#manual-de-uso-de-sfml","title":"Manual de Uso de SFML","text":"<p>SFML proporciona una API orientada a objetos que agiliza el desarrollo de aplicaciones multimedia. A continuaci\u00f3n, se presentan los componentes fundamentales de la biblioteca, cada uno ilustrado con un ejemplo de c\u00f3digo que demuestra su uso pr\u00e1ctico:</p> <ul> <li> <p><code>sf::RenderWindow</code> (M\u00f3dulo <code>window</code>): Es el pilar de cualquier aplicaci\u00f3n SFML. Representa la ventana del sistema operativo y act\u00faa como el lienzo sobre el cual se realizan todas las operaciones de dibujado. Gestiona el bucle principal del programa (<code>isOpen()</code>) y el ciclo de renderizado (<code>clear()</code>, <code>draw()</code>, <code>display()</code>).</p> <pre><code>// Crea una ventana de 800x600 p\u00edxeles con un t\u00edtulo\nsf::RenderWindow window(sf::VideoMode({800, 600}), \"Mi Ventana\");\nwhile (window.isOpen()) {\n    // ... L\u00f3gica de eventos y actualizaci\u00f3n ...\n    window.clear(); // Limpia la pantalla\n    // ... window.draw(...) para dibujar objetos ...\n    window.display(); // Muestra el nuevo fotograma\n}\n</code></pre> </li> <li> <p><code>sf::Event</code> (M\u00f3dulo <code>window</code>): Encapsula todos los eventos de entrada del usuario y del sistema (movimiento del rat\u00f3n, clics, pulsaciones de teclado, cierre de la ventana, etc.). Los eventos se procesan en una cola que se consulta en cada fotograma mediante <code>pollEvent()</code>.</p> <pre><code>// Dentro del bucle principal (while window.isOpen())\nwhile (const std::optional&lt;sf::Event&gt; event = window.pollEvent()) {\n    // El evento m\u00e1s com\u00fan: cerrar la ventana\n    if (event-&gt;is&lt;sf::Event::Closed&gt;()) {\n        window.close();\n    }\n}\n</code></pre> </li> <li> <p><code>sf::Drawable</code> y <code>sf::Transformable</code> (M\u00f3dulo <code>graphics</code>): Son las clases base para cualquier objeto que se pueda dibujar y transformar (mover, rotar, escalar). Las clases m\u00e1s comunes que heredan de ellas son:</p> <ul> <li><code>sf::Shape</code>: Base para formas geom\u00e9tricas. <code>sf::ConvexShape</code> es una de sus derivadas, que permite crear pol\u00edgonos convexos personalizados.</li> <li><code>sf::Sprite</code>: Para dibujar im\u00e1genes y texturas.</li> <li><code>sf::Text</code>: Para renderizar texto en pantalla.</li> </ul> <pre><code>// Crea una forma, la personaliza y la posiciona\nsf::CircleShape circulo(50.f); // Radio de 50 p\u00edxeles\ncirculo.setFillColor(sf::Color::Green);\ncirculo.setPosition({100.f, 100.f});\n// Para dibujarlo: window.draw(circulo);\n</code></pre> </li> <li> <p><code>sf::Clock</code> (M\u00f3dulo <code>system</code>): Proporciona una forma sencilla y precisa de medir el tiempo transcurrido. Es esencial para implementar animaciones, f\u00edsicas o cualquier l\u00f3gica que dependa del tiempo y no de la velocidad de los fotogramas.</p> <pre><code>sf::Clock clock; // El cron\u00f3metro empieza a contar aqu\u00ed\n// ... m\u00e1s tarde en el c\u00f3digo ...\nsf::Time elapsed = clock.getElapsedTime();\n// Reinicia el cron\u00f3metro para la siguiente medici\u00f3n\nclock.restart();\n</code></pre> </li> </ul>"},{"location":"technical_report/graphics_lib/#demostracion-de-uso-de-sfml","title":"Demostraci\u00f3n de Uso de SFML","text":"<p>A continuaci\u00f3n, se presenta un ejemplo completo que utiliza varias funcionalidades de SFML, incluyendo la creaci\u00f3n de una ventana, el manejo de eventos, el renderizado de gr\u00e1ficos y la reproducci\u00f3n de audio:</p> <p><pre><code>#include &lt;SFML/Audio.hpp&gt;\n#include &lt;SFML/Graphics.hpp&gt;\n\nint main()\n{\n    // Create the main window\n    sf::RenderWindow window(sf::VideoMode({800, 600}), \"SFML window\");\n\n    // Load a sprite to display\n    const sf::Texture texture(\"cute_image.jpg\");\n    sf::Sprite sprite(texture);\n\n    // Create a graphical text to display\n    const sf::Font font(\"arial.ttf\");\n    sf::Text text(font, \"Hello SFML\", 50);\n\n    // Load a music to play\n    sf::Music music(\"nice_music.ogg\");\n\n    // Play the music\n    music.play();\n\n    // Start the game loop\n    while (window.isOpen())\n    {\n        // Process events\n        while (const std::optional event = window.pollEvent())\n        {\n            // Close window: exit\n            if (event-&gt;is&lt;sf::Event::Closed&gt;())\n                window.close();\n        }\n\n        // Clear screen\n        window.clear();\n\n        // Draw the sprite\n        window.draw(sprite);\n\n        // Draw the string\n        window.draw(text);\n\n        // Update the window\n        window.display();\n    }\n}\n</code></pre> Ejemplo de uso de algunas de las funcionalidades de SFML extra\u00eddo de la documentaci\u00f3n oficial.</p>"},{"location":"technical_report/graphics_lib/#uso-de-sfml-en-el-proyecto-un-enfoque-practico","title":"Uso de SFML en el Proyecto: Un Enfoque Pr\u00e1ctico","text":"<p>Una vez establecida la base de SFML con cada uno de sus m\u00f3dulos (en nuestro caso, <code>window</code>, <code>graphics</code> y <code>system</code>) y comprendidas sus caracter\u00edsticas, se aplicaron en el desarrollo del juego \"Escape the Grid\".</p> <ul> <li> <p>Gesti\u00f3n de la Ventana y Bucle Principal (<code>sf::RenderWindow</code>)   La clase <code>sf::RenderWindow</code> es el pilar de la aplicaci\u00f3n. Encapsula la ventana del sistema operativo y es el objetivo de todas las operaciones de dibujado. El bucle principal del juego se estructura en torno al m\u00e9todo <code>window.isOpen()</code> por el cual, la clase, controla el ciclo de vida de la aplicaci\u00f3n. Dentro de este bucle, se sigue el ciclo de renderizado en tiempo real basado en doble b\u00fafer para evitar parpadeos (flickering):</p> <ul> <li>Procesamiento de Eventos: Se gestiona la entrada del usuario.</li> <li>Actualizaci\u00f3n de L\u00f3gica: Se actualiza el estado de todos los objetos del juego.</li> <li> <p>Renderizado: Se limpia el fotograma anterior (<code>window.clear()</code>), se dibujan todos los objetos en un b\u00fafer oculto (<code>window.draw(...)</code>), y finalmente se muestra el resultado en pantalla (<code>window.display()</code>). Adem\u00e1s, se us\u00f3 <code>setFramerateLimit(60)</code> para estabilizar la velocidad de actualizaci\u00f3n.</p> <pre><code>// En main.cpp\nsf::RenderWindow window(sf::VideoMode({1280, 720}), \"Escape the Grid\");\nwindow.setFramerateLimit(60);\n\nwhile (window.isOpen())\n{\n// ... L\u00f3gica de eventos y actualizaci\u00f3n ...\n    window.clear(sf::Color(44, 62, 80));\n    // ... Llamadas a window.draw(...) para cada objeto ...\n    window.display();\n}\n</code></pre> </li> </ul> </li> <li> <p>Sistema de Eventos para la Interacci\u00f3n (<code>sf::Event</code>)   Para cumplir con el requisito de una interacci\u00f3n 100% por rat\u00f3n, se utiliz\u00f3 el sistema de eventos de SFML. En cada fotograma, un bucle while (<code>window.pollEvent(event)</code>) procesa la cola de eventos del sistema operativo. Se opt\u00f3 por un enfoque moderno y seguro de C++ 17, <code>event-&gt;getIf&lt;T&gt;()</code>, para gestionar los diferentes tipos de eventos, enfoc\u00e1ndonos en <code>sf::Event::MouseButtonPressed</code>:</p> <pre><code>// En main.cpp, dentro del bucle de eventos\nwhile (const std::optional&lt;sf::Event&gt; event = window.pollEvent())\n{\n    if (const auto *mousePress = event-&gt;getIf&lt;sf::Event::MouseButtonPressed&gt;()) {\n        if (mousePress-&gt;button == sf::Mouse::Button::Left) {\n                // L\u00f3gica para clics del rat\u00f3n...\n                sf::Vector2f mousePos = window.mapPixelToCoords(mousePress-&gt;position);\n                // ...\n        }\n    }\n}\n</code></pre> </li> <li> <p>Renderizado de Entidades Gr\u00e1ficas (<code>sf::ConvexShape</code>)   El requisito de una malla de tri\u00e1ngulos exig\u00eda una soluci\u00f3n de renderizado flexible (pol\u00edgonos convexos). La clase <code>sf::ConvexShape</code> fue la herramienta ideal. A diferencia de formas predefinidas, permite crear cualquier pol\u00edgono convexo definiendo la posici\u00f3n de cada uno de sus v\u00e9rtices. Para cada <code>TrianguloNode</code> en nuestro <code>GridModel</code>, se cre\u00f3 una instancia de <code>sf::ConvexShape</code>y se le asignan 3 v\u00e9rtices para formar el tri\u00e1ngulo exacto en su posici\u00f3n, d\u00e1ndonos control total sobre la geometr\u00eda del mapa.</p> <pre><code>// Concepto de implementaci\u00f3n en GridModel.cpp\nTrianguloNode nuevoNodo;\nnuevoNodo.shape.setPointCount(3);\nnuevoNodo.shape.setPoint(0, {x, y});\nnuevoNodo.shape.setPoint(1, {x + lado, y});\nnuevoNodo.shape.setPoint(2, {x + anchoMedio, y + altura});\n</code></pre> </li> <li> <p>Control del Tiempo y Animaciones (<code>sf::Clock</code>) Para crear una experiencia de usuario fluida, se implementaron m\u00faltiples animaciones. La clase <code>sf::Clock</code> fue la base para toda la temporizaci\u00f3n. Act\u00faa como un cron\u00f3metro de alta precisi\u00f3n que se puede reiniciar y consultar. El patr\u00f3n utilizado para todas las animaciones fue:</p> <ul> <li>Iniciar un reloj (<code>restart()</code>) al comenzar una animaci\u00f3n.</li> <li>En cada fotograma, calcular el progreso (un valor de 0.0 a 1.0) dividiendo el tiempo transcurrido por la duraci\u00f3n total de la animaci\u00f3n.</li> <li>Usar este progreso para interpolar una propiedad (posici\u00f3n, color, etc.).</li> </ul> <pre><code>// En main.cpp, dentro del bucle principal\nif (isPlayerMoving) {\n    float progress = playerMoveClock.getElapsedTime().asSeconds() / MOVE_DURATION_SECONDS;\n    if (progress &gt;= 1.0f) {\n        isPlayerMoving = false;\n        jugador.setPosicion(playerTargetPos); // Asegura la posici\u00f3n final\n    } else {\n        // Interpola la posici\u00f3n entre el inicio y el destino\n        sf::Vector2f newPos = playerStartPos + (playerTargetPos - playerStartPos) * progress;\n        jugador.setPosicion(newPos);\n    }\n}\n</code></pre> </li> </ul> <p>Note</p> <p>Para m\u00e1s informaci\u00f3n sobre SFML y su uso con CMake, se puede consultar SFML with the CMake Project Template y su documentaci\u00f3n.</p>"},{"location":"technical_report/visualization_engine/","title":"Motor de Visualizaci\u00f3n y Renderizado","text":"<p>El motor de visualizaci\u00f3n de \"Escape the Grid\" es el componente responsable de traducir el estado abstracto del juego (la l\u00f3gica en <code>GridModel</code>, <code>GameState</code> y <code>Player</code>) en una representaci\u00f3n gr\u00e1fica interactiva para el usuario. Construido mediante las funciones de la biblioteca SFML, este motor no solo se encarga de \"dibujar\" objetos, sino tambi\u00e9n de proporcionar feedback visual din\u00e1mico y animaciones que mejoran la experiencia de juego.</p> <p>La visualizaci\u00f3n se puede descomponer en los siguientes componentes clave:</p>"},{"location":"technical_report/visualization_engine/#representacion-del-entorno-y-estado-gridmodel","title":"Representaci\u00f3n del Entorno y Estado (<code>GridModel</code>)","text":"<p>La clase <code>GridModel</code> es el n\u00facleo de la visualizaci\u00f3n del mapa del juego. Para que el jugador pudiera entender el estado del juego de un solo vistazo, se utilizaron varias t\u00e9cnicas de retroalimentaci\u00f3n visual directa.</p> <ul> <li>Interpretaci\u00f3n del Mapa desde Archivo: La estructura del nivel se carga desde un archivo de texto (<code>.txt</code>). El m\u00e9todo <code>cargarDesdeArchivo</code> interpreta cada car\u00e1cter del archivo y lo asocia a un tipo de celda (<code>TipoCelda</code>), que a su vez define su color y comportamiento.</li> </ul> <p><pre><code>// Ejemplo de un archivo de mapa simple (mapa.txt)\nWWWWWWWW\nWS.1.T.F\nW..W...W\nW..2.3.W\nWWTT..WW\n</code></pre> Donde:</p> <ul> <li><code>S</code>: Punto de inicio del jugador.</li> <li><code>.</code>: Celda de camino normal, transitable.</li> <li><code>W</code>: Muro, celda no transitable.</li> <li><code>1</code>, <code>2</code>, <code>3</code>: \u00cdtems de secuencia de la \"Caja M\u00e1gica\", que deben ser recogidos en orden.</li> <li><code>T</code>: Muro temporizado, que se convierte en muro (<code>W</code>) despu\u00e9s de un n\u00famero de turnos.</li> <li><code>F</code>: Celda final u objetivo.</li> </ul> <p>La correspondencia de caracteres se gestiona con un <code>switch</code> dentro de <code>GridModel.cpp</code>:</p> <pre><code>// En GridModel.cpp\n        else\n        {\n            char caracter = mapaDeCaracteres[fila][col];\n            switch (caracter)\n            {\n            case 'S':\n                tipo = TipoCelda::INICIO;\n                colorCelda = sf::Color(46, 204, 113);\n                break;\n            case 'W':\n                tipo = TipoCelda::PARED;\n                colorCelda = sf::Color(52, 73, 94);\n                break;\n            case 'F':\n                tipo = TipoCelda::FIN_OCULTO;\n                colorCelda = sf::Color(189, 195, 199);\n                posicionSalida = {(int)col, (int)fila};\n                break;\n            case 'T':\n                tipo = TipoCelda::TIMED_WALL;\n                colorCelda = sf::Color(52, 152, 219);\n                break;\n            case '1':\n            case '2':\n            case '3':\n                tipo = TipoCelda::ITEM_SECUENCIA;\n                colorCelda = sf::Color(241, 196, 15);\n                break;\n            default:\n                tipo = TipoCelda::NORMAL;\n                colorCelda = sf::Color(189, 195, 199);\n                break;\n            }\n        }\n// ...\n</code></pre> <ul> <li> <p>Generaci\u00f3n Procedural de la Malla: Durante la carga, el <code>GridModel</code> no solo lee el mapa, sino que calcula din\u00e1micamente la geometr\u00eda de cada tri\u00e1ngulo. Bas\u00e1ndose en el tama\u00f1o de la ventana y las dimensiones del mapa, determina el tama\u00f1o y la posici\u00f3n de cada <code>sf::ConvexShape</code> para que la malla ocupe el espacio de forma \u00f3ptima.</p> </li> <li> <p>Retroalimentaci\u00f3n de Celdas Visitadas: Para ayudar al jugador a orientarse, las celdas ya visitadas se marcan visualmente. La funci\u00f3n <code>marcarNodoVisitado</code> toma el color actual del tri\u00e1ngulo y lo oscurece, dejando un \"rastro\" visual claro.</p> </li> </ul> <pre><code>// En GridModel.cpp\nvoid GridModel::marcarNodoVisitado(int nodeId)\n{\n    if (nodeId &lt; 0 || static_cast&lt;size_t&gt;(nodeId) &gt;= nodosDelGrid.size())\n        return;\n    auto &amp;nodo = nodosDelGrid[nodeId];\n    if ((nodo.tipo == TipoCelda::NORMAL || nodo.tipo == TipoCelda::FIN_OCULTO || nodo.tipo == TipoCelda::ITEM_SECUENCIA) &amp;&amp; !nodo.haSidoVisitado)\n    {\n        nodo.haSidoVisitado = true;\n        sf::Color colorActual = nodo.shape.getFillColor();\n        nodo.shape.setFillColor(sf::Color(colorActual.r / 1.5, colorActual.g / 1.5, colorActual.b / 1.5));\n    }\n}\n// ...\n</code></pre> <ul> <li>Resaltado de Interacci\u00f3n (\"Hover\"): Para mejorar la interactividad, la funci\u00f3n <code>GridModel::actualizar</code> detecta en cada fotograma la posici\u00f3n del rat\u00f3n. Si el cursor est\u00e1 sobre un tri\u00e1ngulo v\u00e1lido, el borde de ese tri\u00e1ngulo cambia a color blanco, dando una se\u00f1al inequ\u00edvoca de la selecci\u00f3n.</li> </ul> <pre><code>// En GridModel.cpp\n    for (size_t i = 0; i &lt; nodosDelGrid.size(); ++i)\n    {\n        if (nodosDelGrid[i].tipo != TipoCelda::PARED &amp;&amp; nodosDelGrid[i].tipo != TipoCelda::VACIO &amp;&amp; nodosDelGrid[i].shape.getGlobalBounds().contains(posicionRaton))\n        {\n            nodosDelGrid[i].shape.setOutlineColor(sf::Color::White);\n            idTrianguloResaltado = i;\n            break;\n        }\n    }\n// ...\n</code></pre> <ul> <li>Dibujado del Grid: El m\u00e9todo <code>dibujar(sf::RenderWindow&amp; ventana)</code> simplemente itera sobre el vector <code>nodosDelGrid</code> y llama a <code>ventana.draw()</code> para cada <code>sf::ConvexShape</code>, renderizando eficientemente todo el mapa.</li> </ul>"},{"location":"technical_report/visualization_engine/#visualizacion-de-entidades-y-hud","title":"Visualizaci\u00f3n de Entidades y HUD","text":"<p>Sobre el mapa base se renderizan las entidades din\u00e1micas y la interfaz de usuario (HUD).</p> <ul> <li> <p>El Jugador (<code>Player</code>): La clase <code>Player</code> encapsula una <code>sf::CircleShape</code>. Su posici\u00f3n no es gestionada por la clase misma, sino por la l\u00f3gica central en <code>main.cpp</code>, que le asigna una nueva coordenada bas\u00e1ndose en el nodo del grid en el que se encuentra.</p> </li> <li> <p>Interfaz de Usuario (HUD): Toda la informaci\u00f3n para el jugador (puntuaci\u00f3n, turnos, objetivo actual) se gestiona en <code>main.cpp</code> mediante objetos <code>sf::Text</code>. Estos objetos se actualizan en cada fotograma con los datos m\u00e1s recientes del <code>GameState</code> y se dibujan en una capa superior al juego.</p> </li> </ul> <pre><code>// En main.cpp\n    scoreText.setString(\"Puntaje: \" + std::to_string(estadoJuego.getScore()));\n    turnText.setString(\"Turno: \" + std::to_string(estadoJuego.getCurrentTurn()));\n    int proximoItem = estadoJuego.getNextSequenceItem();\n    if (proximoItem &gt; 3) { sequenceText.setString(\"Objetivo: Ve a la Salida!\"); }\n    else { sequenceText.setString(\"Objetivo: Item \" + std::to_string(proximoItem)); }\n// ...\n</code></pre>"},{"location":"technical_report/visualization_engine/#sistema-de-animaciones-basado-en-tiempo","title":"Sistema de Animaciones Basado en Tiempo","text":"<p>Para evitar transiciones bruscas y crear una experiencia de usuario fluida, todos los efectos visuales din\u00e1micos se implementaron a trav\u00e9s de un sistema de animaci\u00f3n basado en tiempo, independiente de la velocidad de fotogramas del equipo.</p> <p>El Rol Central de <code>sf::Clock</code>: La clase <code>sf::Clock</code> de SFML fue la herramienta fundamental, tal como se explic\u00f3 su uso en la secci\u00f3n anterior. El patr\u00f3n utilizado consistentemente fue:</p> <ol> <li>Iniciar un reloj (<code>restart()</code>) al comenzar una animaci\u00f3n.</li> <li>En cada fotograma, calcular un valor de progreso (de 0.0 a 1.0) dividiendo el tiempo transcurrido (<code>getElapsedTime()</code>) por la duraci\u00f3n total deseada.</li> <li>Utilizar este valor de progreso para interpolar linealmente la propiedad a animar (posici\u00f3n, opacidad, etc.).</li> </ol> <p>Animaciones Implementadas:</p> <ul> <li>Movimiento Suave del Jugador: Para evitar la \"teletransportaci\u00f3n\" entre celdas, se implement\u00f3 una interpolaci\u00f3n lineal. Al iniciar un movimiento, se almacenan las posiciones de inicio y destino. En cada fotograma, la posici\u00f3n visual del jugador se actualiza a un punto intermedio calculado con la f\u00f3rmula: <code>posicion_actual = pos_inicio + (pos_destino - pos_inicio) * progreso</code>.</li> </ul> <pre><code>// En main.cpp\n    if (isPlayerMoving) {\n        float progress = playerMoveClock.getElapsedTime().asSeconds() / MOVE_DURATION_SECONDS;\n        if (progress &gt;= 1.0f) {\n            isPlayerMoving = false;\n            jugador.setPosicion(playerTargetPos);\n        } else {\n            jugador.setPosicion(playerStartPos + (playerTargetPos - playerStartPos) * progress);\n        }\n    }\n// ...\n</code></pre> <ul> <li> <p>Visualizaci\u00f3n del Solver: Cumpliendo con el requisito de una visualizaci\u00f3n \"paso a paso\" (proporcionar visualizaci\u00f3n en tiempo real y paso a paso de los algoritmos), la soluci\u00f3n se presenta en dos fases animadas:</p> <ol> <li>Fase de Revelado: Una primera animaci\u00f3n (<code>animandoSolucion</code>) utiliza un <code>sf::Clock</code> para dibujar progresivamente los marcadores de la ruta, uno por uno, creando un efecto de \"dibujado\" del camino.</li> <li>Fase de Autoplay: Una vez revelada la ruta, se inicia una segunda animaci\u00f3n (<code>isAutoplaying</code>) donde el personaje del jugador sigue el camino revelado, utilizando la misma l\u00f3gica de movimiento suave para cada paso.</li> </ol> <pre><code>// En GridModel.cpp\nvoid GridModel::dibujarSolucion(sf::RenderWindow &amp;ventana, const std::vector&lt;int&gt; &amp;camino, size_t numPasosAMostrar)\n{\n// ...\n    sf::CircleShape marcador(5.f);\n    marcador.setFillColor(sf::Color(231, 76, 60, 180));\n    marcador.setOrigin({5.f, 5.f});\n    for (size_t i = 0; i &lt; numPasosAMostrar &amp;&amp; i &lt; camino.size(); ++i)\n    {\n        marcador.setPosition(getNodeCenter(camino[i]));\n        ventana.draw(marcador);\n    }\n}\n// ...\n</code></pre> </li> <li> <p>Transiciones de la Interfaz: Para las pantallas de \"GANASTE\" y \"PERDISTE\", se utiliz\u00f3 un <code>sf::Clock</code> para animar el canal alfa (opacidad) del color del texto, logrando un efecto de desvanecimiento suave.   <pre><code>// En main.cpp\n// ...\n    if (currentStatus != GameStatus::Jugando) {\n        window.draw(overlay);\n        const float FADE_DURATION_SECONDS = 1.5f;\n        float progress = std::min(1.f, gameOverFadeClock.getElapsedTime().asSeconds() / FADE_DURATION_SECONDS);\n        std::uint8_t alpha = static_cast&lt;std::uint8_t&gt;(255 * progress);\n        sf::Color textColor;\n// ... (l\u00f3gica para elegir color) ...\n        textColor.a = alpha;\n        gameOverText.setFillColor(textColor);\n// ...\n</code></pre></p> </li> </ul>"},{"location":"technical_report/visualization_engine/#el-bucle-de-renderizado","title":"El Bucle de Renderizado","text":"<p>El orden de dibujado es crucial y se gestiona en el bucle principal de <code>main.cpp</code> para asegurar que los elementos se superpongan correctamente:</p> <ol> <li><code>window.clear()</code>: Se limpia la pantalla con un color de fondo s\u00f3lido.</li> <li><code>miGrid.dibujar()</code>: Se dibuja la malla de tri\u00e1ngulos.</li> <li><code>miGrid.dibujarSolucion()</code>: Se dibuja la animaci\u00f3n del camino soluci\u00f3n (si est\u00e1 activa).</li> <li><code>jugador.dibujar()</code>: Se dibuja al jugador sobre el grid.</li> <li><code>window.draw(HUD)</code>: Se dibujan todos los textos y botones de la interfaz.</li> <li><code>window.draw(Overlay)</code>: Se dibuja la capa de fin de juego (si est\u00e1 activa).</li> <li><code>window.display()</code>: Se intercambia el b\u00fafer de renderizado con el visible, mostrando el fotograma final al usuario.</li> </ol> <p>Note</p> <p>Para m\u00e1s informaci\u00f3n sobre como funcionan las clases de SFML, se puede consultar la secci\u00f3n Biblioteca Gr\u00e1fica y Manual de Uso.</p>"},{"location":"user_guide/compilation/","title":"Instrucciones de Compilaci\u00f3n","text":"<p>Este apartado sobre Instrucciones de Compilaci\u00f3n describe el proceso completo para preparar el entorno y compilar el proyecto \"Escape the Grid\". Sigue las instrucciones cuidadosamente para asegurarte de que todo funcione correctamente.</p>"},{"location":"user_guide/compilation/#requisitos-previos","title":"Requisitos Previos","text":"<p>Antes de comenzar, es necesario asegurarse de que todas las herramientas y bibliotecas requeridas est\u00e9n instaladas y configuradas correctamente. A continuaci\u00f3n, se detallan los requisitos previos:</p> <ul> <li>Compilador C++17 compatible con SFML 3.0.0: Visita la secci\u00f3n Compilador C++ en Herramientas y Bibliotecas Requeridas para m\u00e1s detalles.</li> <li>SFML 3.0.0 (Simple and Fast Multimedia Library): Biblioteca multimedia para desarrollo de software.</li> <li>CMake: Herramienta de automatizaci\u00f3n de compilaci\u00f3n que facilita la generaci\u00f3n de archivos de proyecto para diferentes entornos de desarrollo.</li> <li>Editor de c\u00f3digo (VSCode): Te recomendamos utilizar Visual Studio Code. Haz click aqu\u00ed para descargar.</li> <li>Git: Configurado previamente con tu cuenta de Github para clonar el repositorio del proyecto. Haz click aqu\u00ed para descargar.</li> </ul> <p>Compatibilidad de Versiones</p> <p>Es necesario que las versiones de las herramientas y bibliotecas coincidan con las especificadas en el proyecto para evitar problemas de compatibilidad. Para m\u00e1s informaci\u00f3n, consulta cada una de las secciones en Herramientas y Bibliotecas Requeridas.</p>"},{"location":"user_guide/compilation/#configuracion-y-compilacion-del-proyecto-escape-the-grid","title":"Configuraci\u00f3n y Compilaci\u00f3n del Proyecto: Escape the Grid","text":""},{"location":"user_guide/compilation/#extensiones-de-visual-studio-code","title":"Extensiones de Visual Studio Code","text":"<p>Antes de comenzar, aseg\u00farate de tener Visual Studio Code configurado correctamente con las extensiones necesarias para trabajar con C++ y CMake.</p> <ol> <li>Abre Visual Studio Code.</li> <li>Navega a la secci\u00f3n de extensiones en la barra lateral izquierda.</li> </ol> <p></p> <ol> <li> <p>Busca e instala las extensiones necesarias:</p> <ul> <li> <p>C/C++ por Microsoft: Proporciona soporte para el lenguaje C++.</p> </li> <li> <p>CMake Tools por Microsoft: Facilita la integraci\u00f3n de CMake en Visual Studio Code.</p> </li> </ul> </li> <li> <p>Una vez instaladas las extensiones, reinicia Visual Studio Code para que los cambios surtan efecto.</p> </li> </ol>"},{"location":"user_guide/compilation/#clonacion-del-repositorio","title":"Clonaci\u00f3n del Repositorio","text":"<p>Ahora, necesitamos clonar el repositorio del proyecto desde GitHub. Aseg\u00farate de tener Git instalado y configurado en tu sistema.</p> <ol> <li>Abre una terminal en la ubicaci\u00f3n donde deseas clonar el repositorio.</li> <li> <p>Ejecuta el siguiente comando para clonar el repositorio:</p> <pre><code>git clone https://github.com/UCASV/programming-challenge-tsc012025-pc-grupo24.git\n</code></pre> <p>Nota</p> <p>No cierres la terminal despu\u00e9s de clonar el repositorio, la ocuparemos para el siguiente paso.</p> </li> </ol>"},{"location":"user_guide/compilation/#configuracion-del-proyecto-en-visual-studio-code","title":"Configuraci\u00f3n del Proyecto en Visual Studio Code","text":"<p>Para este paso, aseg\u00farate de que todas las herramientas y bibliotecas mencionadas en los requisitos previos est\u00e9n correctamente instaladas y configuradas.</p> <ol> <li> <p>Una vez clonado el repositorio, en la misma terminal, navega al directorio del proyecto utilizando el siguiente comando:</p> <pre><code>cd programming-challenge-tsc012025-pc-grupo24\n</code></pre> </li> <li> <p>Ejecuta el siguiente comando para abrir la carpeta del proyecto en Visual Studio Code:</p> <pre><code>code .\n</code></pre> </li> <li> <p>Al inciar, se te mostrar\u00e1 una ventana para seleccionar el kit de CMake. Aseg\u00farate de seleccionar el kit que corresponde a tu compilador C++ instalado (<code>GCC 14.2.0...</code>).</p> <p></p> <p>Informaci\u00f3n</p> <p>Si no ves la ventana para seleccionar el kit de CMake, puedes abrirla manualmente presionando <code>Ctrl + Shift + P</code> y buscando \"CMake: Select a Kit\".</p> </li> <li> <p>Una vez seleccionado el kit, Visual Studio Code comenzar\u00e1 a configurar el proyecto. Espera a que se complete el proceso.</p> <p>Informaci\u00f3n</p> <p>Notar\u00e1s que se cre\u00f3 un folder llamado <code>build</code> en la ra\u00edz del proyecto. Este es el directorio donde se generar\u00e1n los archivos de compilaci\u00f3n. Por el momento, no te preocupes por este folder, ya que lo utilizaremos m\u00e1s adelante.</p> </li> <li> <p>Ahora, dirigete a la opci\u00f3n \"Ejecuci\u00f3n y Depuraci\u00f3n\" en la barra lateral izquierda de Visual Studio Code.</p> <p></p> </li> <li> <p>Selecciona la opci\u00f3n \"Cree un archivo <code>launch.json</code>\" y luego, en la ventana emergente, elige \"C++ (GDB/LLDB)\".</p> <p></p> <p>Informaci\u00f3n</p> <p>Notar\u00e1s que se cre\u00f3 un archivo <code>launch.json</code> en la carpeta <code>.vscode</code> en la ra\u00edz del proyecto.</p> </li> <li> <p>Ingresa a este archivo <code>launch.json</code> que se cre\u00f3 en el paso anterior y reemplaza el contenido con la siguiente configuraci\u00f3n. Luego, guarda los cambios.</p> <pre><code>{\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"name\": \"Debug\",\n            \"type\": \"cppdbg\",\n            \"request\": \"launch\",\n            \"program\": \"${workspaceFolder}/build/EscapeTheGrid.exe\",\n            \"args\": [],\n            \"stopAtEntry\": false,\n            \"cwd\": \"${workspaceFolder}\",\n            \"environment\": [],\n            \"externalConsole\": false,\n            \"MIMode\": \"gdb\",\n            \"setupCommands\": [\n                {\n                    \"description\": \"Enable pretty-printing for gdb\",\n                    \"text\": \"-enable-pretty-printing\",\n                    \"ignoreFailures\": true\n                }\n            ],\n            \"preLaunchTask\": \"build\"\n        }\n    ]\n}\n</code></pre> <p>Informaci\u00f3n</p> <p>Este archivo de configuraci\u00f3n le indica a Visual Studio Code c\u00f3mo ejecutar y depurar el proyecto.</p> </li> </ol>"},{"location":"user_guide/compilation/#compilacion-del-proyecto","title":"Compilaci\u00f3n del Proyecto","text":"<p>\u00a1Ya est\u00e1 casi listo! Ahora, necesitamos que el proyecto se compile correctamente. Para eso, tenemos que agregar unos archivos de configuraci\u00f3n adicionales de SFML 3.0.0 que son necesarios para que el proyecto funcione.</p> <ol> <li> <p>Busca la carpeta donde extra\u00edste SFML 3.0.0 en el paso de instalaci\u00f3n de SFML. Deber\u00edas tener una estructura de carpetas similar a esta:</p> <pre><code>C:\\&lt;nombre_de_carpeta&gt;\\SFML-3.0.0\n</code></pre> </li> <li> <p>Dentro de la carpeta <code>SFML-3.0.0</code>, localiza la carpeta <code>bin</code> y entra en ella. </p> <p></p> </li> <li> <p>Una vez dentro de la carpeta <code>bin</code>, copia estos archivos <code>.dll</code> necesarios como se muestra en la imagen:</p> <ul> <li><code>sfml-graphics-d-3.dll</code></li> <li><code>sfml-window-d-3.dll</code></li> <li><code>sfml-system-d-3.dll</code></li> </ul> <p></p> <p>Informaci\u00f3n</p> <p>Escape The Grid utiliza los m\u00f3dulos <code>Graphics</code>, <code>Window</code> y <code>System</code> de SFML 3.0.0, por lo que solo necesitar\u00e1s los archivos <code>.dll</code> correspondientes a estos m\u00f3dulos.</p> </li> <li> <p>Ahora, ve a la carpeta <code>build</code> que se cre\u00f3 en la ra\u00edz del proyecto cuando configuraste CMake en Visual Studio Code. Pega los archivos <code>.dll</code> que copiaste en el paso anterior dentro de esta carpeta <code>build</code>.</p> <p></p> </li> <li> <p>Una vez que hayas pegado los archivos <code>.dll</code>, regresa a Visual Studio Code y abre la paleta de comandos presionando <code>Ctrl + Shift + P</code>. Busca y selecciona la opci\u00f3n <code>CMake: Build</code>. Esto iniciar\u00e1 el proceso de compilaci\u00f3n del proyecto.</p> <p></p> <p>Informaci\u00f3n</p> <p>Espera a que la compilaci\u00f3n se complete. Si todo est\u00e1 configurado correctamente, deber\u00edas ver un mensaje de \u00e9xito en la terminal de Visual Studio Code.</p> </li> <li> <p>Una vez que la compilaci\u00f3n haya finalizado, dir\u00edgete nuevamente a la secci\u00f3n de \"Ejecuci\u00f3n y Depuraci\u00f3n\" en la barra lateral izquierda de Visual Studio Code. Presiona el bot\u00f3n de \"Iniciar Depuraci\u00f3n\" (o <code>F5</code> si te encuentras en Windows) para ejecutar el proyecto.</p> <p></p> </li> <li> <p>Si has hecho todo correctamente, deber\u00edas de poder ver la ventana del juego.</p> <p></p> </li> </ol> <p>\u00a1Felicidades!</p> <p>Ahora ya sabes c\u00f3mo compilar y ejecutar con \u00e9xito el proyecto Escape the Grid. Puedes disfrutar del juego, explorar sus mec\u00e1nicas desafiantes o modificar el c\u00f3digo para agregar nuevas caracter\u00edsticas.</p>"},{"location":"user_guide/custom_maps/","title":"Mapas Personalizados","text":"<p>Si te sientes creativo y quieres dise\u00f1ar tus propios laberintos, puedes crear mapas personalizados para Escape the Grid. Aqu\u00ed te explicamos c\u00f3mo hacerlo.</p>"},{"location":"user_guide/custom_maps/#comprension-de-mapas-personalizados","title":"Comprensi\u00f3n de Mapas Personalizados","text":"<p>Antes de comenzar a crear tus propios mapas, es importante entender la estructura de un mapa en Escape the Grid para que tu mapa sea funcional y desafiante.</p>"},{"location":"user_guide/custom_maps/#estructura-del-archivo","title":"Estructura del Archivo","text":"<p>Los mapas personalizados se definen en el archivo de texto <code>mapa.txt</code> con una estructura espec\u00edfica. Cada celda del laberinto se representa por un car\u00e1cter \u00fanico:</p> <ul> <li><code>S</code>: Punto de inicio del jugador.</li> <li><code>.</code>: Celda de camino normal, transitable.</li> <li><code>W</code>: Muro, celda no transitable.</li> <li><code>1</code>, <code>2</code>, <code>3</code>: \u00cdtems de la secuencia de la \"Caja M\u00e1gica\".</li> <li><code>T</code>: Muro temporizado, que se convierte en muro (<code>W</code>) despu\u00e9s de un n\u00famero de turnos.</li> <li><code>F</code>: Celda final u objetivo.</li> </ul> <p>Ejemplo de la estructura de un mapa:</p> <pre><code>WWWWWWWW\nWS.1.T.F\nW..W...W\nW..2.3.W\nWWTT..WW\n</code></pre>"},{"location":"user_guide/custom_maps/#reglas-de-creacion","title":"Reglas de Creaci\u00f3n","text":"<ul> <li>El mapa debe de tener la celda de inicio (<code>S</code>).</li> <li>El mapa debe de tener la celda final (<code>F</code>).</li> <li>Las celdas de la secuencia de la \"Caja M\u00e1gica\" deben estar numeradas del 1 al 3.</li> <li>Se debe de tener en cuenta los turnos (30 movimientos) antes de que los muros temporizados se conviertan en muros permanentes. Es importante hacer el mapa de tal manera que el jugador pueda completar la secuencia de la \"Caja M\u00e1gica\" antes de que los muros temporizados se conviertan en muros permanentes.</li> </ul> <p>Informaci\u00f3n Adicional</p> <p>Si se desean modificar los turnos antes de que se activen los temporizados, \u00fanicamente es posible hacerlo modificando el c\u00f3digo fuente del juego en el archivo <code>config.hpp</code>, ya que actualmente no hay una opci\u00f3n para configurarlo desde el archivo de mapa. Para m\u00e1s detalles sobre c\u00f3mo compilar el juego, revisa la secci\u00f3n de Instrucciones de Compilaci\u00f3n.</p>"},{"location":"user_guide/custom_maps/#donde-encontrar-el-archivo-mapatxt","title":"D\u00f3nde encontrar el Archivo <code>mapa.txt</code>","text":"<p>El archivo <code>mapa.txt</code> se encuentra en la carpeta del ejecutable del juego, espec\u00edficamente en la ra\u00edz. Para m\u00e1s informaci\u00f3n sobre como obtener el juego, revisa la secci\u00f3n de Controles y Jugabilidad.</p> <p></p>"},{"location":"user_guide/custom_maps/#como-crear-o-modificar-un-mapa","title":"C\u00f3mo Crear o Modificar un Mapa","text":"<p>Para crear o modificar un mapa personalizado, sigue estos pasos:</p> <ol> <li>Abre el archivo <code>mapa.txt</code> ubicado en la carpeta del ejecutable del juego en un editor de texto (como Notepad, Visual Studio Code, etc.).</li> <li>Escribe o edita el contenido del archivo siguiendo la estructura mencionada anteriormente.</li> <li>Guarda los cambios en el archivo <code>mapa.txt</code>.</li> </ol> <p>Informaci\u00f3n</p> <p>El mismo proceso es utilizado para crear o modificar mapas personalizados en la versi\u00f3n de compilaci\u00f3n del juego. El archivo <code>mapa.txt</code> se encuentra en la ra\u00edz del proyecto. Para m\u00e1s informaci\u00f3n sobre c\u00f3mo compilar el juego, revisa la secci\u00f3n de Instrucciones de Compilaci\u00f3n.</p>"},{"location":"user_guide/custom_maps/#como-probar-tu-mapa","title":"C\u00f3mo Probar tu Mapa","text":"<p>Una vez que hayas creado o modificado el archivo <code>mapa.txt</code>, simplemente inicia el juego abriendo el archivo <code>.exe</code>. El juego cargar\u00e1 autom\u00e1ticamente el mapa definido en este archivo. Si el mapa es v\u00e1lido, podr\u00e1s jugarlo inmediatamente.</p> <p>Precauci\u00f3n</p> <ul> <li> <p>Aseg\u00farate de que el mapa sea v\u00e1lido y siga las Reglas de Creaci\u00f3n. Si el mapa no es v\u00e1lido, el juego podr\u00eda no funcionar correctamente, el mapa podr\u00eda no cargar o podr\u00eda haber errores inesperados.</p> </li> <li> <p>El mapa no puede contener otro nombre de archivo que no sea <code>mapa.txt</code>. Si deseas probar un mapa diferente, simplemente reemplaza el contenido del archivo <code>mapa.txt</code> con tu nuevo dise\u00f1o.</p> </li> </ul>"},{"location":"user_guide/custom_maps/#mapas-personalizados-recomendados","title":"Mapas Personalizados Recomendados","text":"<p>Prueba algunos de los siguientes mapas personalizados para comenzar. Del m\u00e1s f\u00e1cil al m\u00e1s dif\u00edcil:</p>"},{"location":"user_guide/custom_maps/#nivel-facil","title":"Nivel F\u00e1cil","text":"<pre><code>S......1\n2T3\nF\n</code></pre>"},{"location":"user_guide/custom_maps/#nivel-intermedio","title":"Nivel Intermedio","text":"<pre><code>WWWWWWWW\nWS.1.T.F\nW..W...W\nW..2.3.W\nWWTT..WW\n</code></pre>"},{"location":"user_guide/custom_maps/#nivel-dificil","title":"Nivel Dif\u00edcil","text":"<pre><code>S.....T2\n...W.....\nW.1......\n.........\n...WWWWW.\n.T...3.W.\n..WWW..F.\n.........\n</code></pre>"},{"location":"user_guide/custom_maps/#nivel-demencial","title":"Nivel Demencial","text":"<pre><code>S...................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n........1...........................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n...........................3........................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n....................................................................................................................................................................\n.................................................................2.................................................................................................F\n</code></pre> <p>Nivel Demencial</p> <p>Este nivel es para poner aprueba las capacidades del algoritmo de resoluci\u00f3n autom\u00e1tica. En total son aproximadamente 10,000 casillas. El algoritmo de resoluci\u00f3n autom\u00e1tica puede tardar en dibujar la soluci\u00f3n, pero encuentra la soluci\u00f3n de manera eficiente. Si deseas ver c\u00f3mo se resuelve este nivel, puedes activar el modo de resoluci\u00f3n autom\u00e1tica desde el panel lateral derecho del juego.</p>"},{"location":"user_guide/how_to_play/","title":"Controles y Jugabilidad","text":"<p>Bienvenido a la gu\u00eda de juego de Escape the Grid: The Magic Box. En esta secci\u00f3n aprender\u00e1s todo lo necesario para comprender la interfaz del juego, dominar los controles b\u00e1sicos y entender las mec\u00e1nicas que debes dominar para tener \u00e9xito en tu aventura. Tambi\u00e9n conocer\u00e1s el funcionamiento del solver autom\u00e1tico que te ayudar\u00e1 a resolver el laberinto de manera eficiente si necesitas asistencia.</p>"},{"location":"user_guide/how_to_play/#como-obtener-el-juego","title":"C\u00f3mo Obtener el Juego","text":"<p>Pero antes de aprender todo lo necesario y comenzar a jugar, necesitas instalar el juego. Aqu\u00ed te presentamos dos opciones para hacerlo:</p>"},{"location":"user_guide/how_to_play/#opcion-1-descarga-el-ejecutable-recomendado","title":"Opci\u00f3n 1: Descarga el Ejecutable (Recomendado)","text":"<p>La manera m\u00e1s sencilla de empezar es descargar el archivo <code>.zip</code> que contiene el juego listo para usar.</p> <ol> <li>Descarga el archivo <code>.zip</code> desde este enlace</li> <li>Extrae el contenido del archivo en la ubicaci\u00f3n de tu preferencia</li> <li>Ejecuta el archivo <code>EscapeTheGrid.exe</code> para iniciar el juego</li> </ol> <p>Recomendaci\u00f3n</p> <p>Esta opci\u00f3n es ideal si solo quieres jugar sin preocuparte por el c\u00f3digo fuente o la compilaci\u00f3n.</p>"},{"location":"user_guide/how_to_play/#opcion-2-compilacion-desde-el-codigo-fuente","title":"Opci\u00f3n 2: Compilaci\u00f3n desde el C\u00f3digo Fuente","text":"<p>Si prefieres compilar el juego por tu cuenta (para agregar nuevas caracter\u00edsticas o para asegurarte de que funcione \u00f3ptimamente en tu sistema). Sigue las instrucciones detalladas en la secci\u00f3n Instrucciones de Compilaci\u00f3n</p> <p>Importante</p> <p>Esta opci\u00f3n requiere conocimientos b\u00e1sicos de programaci\u00f3n y las herramientas mencionadas en la secci\u00f3n de compilaci\u00f3n.</p>"},{"location":"user_guide/how_to_play/#preparandote-para-jugar","title":"Prepar\u00e1ndote para Jugar","text":"<p>Una vez que tengas el juego instalado y en funcionamiento, es hora de aprender c\u00f3mo se juega. A continuaci\u00f3n, te explicamos la interfaz del juego, los controles b\u00e1sicos y las mec\u00e1nicas que debes dominar para tener \u00e9xito.</p>"},{"location":"user_guide/how_to_play/#interfaz-de-usuario","title":"Interfaz de Usuario","text":"<p>La interfaz del juego incluye varios elementos importantes:</p> <ul> <li> <p>Panel de Informaci\u00f3n: Ubicado en la parte derecha de la pantalla.</p> <ul> <li>Puntaje: Muestra tus puntos actuales (comienzas con 1000).</li> <li>Turnos: Indica el n\u00famero de turnos que has jugado.</li> <li> <p>Pr\u00f3ximo Objetivo: Se\u00f1ala cu\u00e1l es el siguiente elemento de la secuencia que debes activar.</p> </li> <li> <p>Botones de Control:</p> <ul> <li>Reiniciar: Reinicia el juego desde el principio.</li> <li>Resolver: Activa el algoritmo de soluci\u00f3n autom\u00e1tica, que encontrar\u00e1 y mostrar\u00e1 la ruta \u00f3ptima.</li> </ul> </li> </ul> </li> <li> <p>Visualizaci\u00f3n del Tablero: El \u00e1rea izquierda muestra el laberinto de tri\u00e1ngulos donde interactuar\u00e1s con el juego.</p> <p></p> <p></p> </li> </ul>"},{"location":"user_guide/how_to_play/#tipos-de-celdas","title":"Tipos de Celdas","text":"<ul> <li>Celda Verde: Representa el inicio del puzzle.</li> <li>Celdas Blancas: Representan las celdas vac\u00edas donde puedes moverte.</li> <li>Celdas Gris Oscuro: Son las paredes del laberinto, que no puedes atravesar.</li> <li>Celdas Amarillas: Son las celdas que debes activar en el orden correcto para completar la secuencia de la Caja M\u00e1gica.</li> <li>Celdas Azules: Se convertir\u00e1n en muros despu\u00e9s de 30 turnos, bloqueando el acceso a ellas.</li> <li>Celdas Grises: Representan el camino que ya has recorrido. No podr\u00e1s volver a estas celdas sin perder puntos.</li> <li>Celda Rosada: Representan la salida del laberinto, que se har\u00e1 visible una vez que completes la secuencia de la Caja M\u00e1gica.</li> </ul>"},{"location":"user_guide/how_to_play/#controles-basicos","title":"Controles B\u00e1sicos","text":"<p>El juego est\u00e1 dise\u00f1ado para ser intuitivo y f\u00e1cil de controlar, utilizando \u00fanicamente el mouse para todas las interacciones.</p>"},{"location":"user_guide/how_to_play/#control-con-el-mouse","title":"Control con el Mouse","text":"<ul> <li> <p>Clic Izquierdo: Es tu herramienta principal para interactuar con el juego.</p> <ul> <li>En Celdas Triangulares: Al hacer clic en una celda adyacente v\u00e1lida, tu personaje se mover\u00e1 hacia ella.</li> <li>En Botones de la Interfaz: Activa las diferentes funciones del juego.</li> </ul> <p></p> <p></p> </li> </ul> <p>Movimientos V\u00e1lidos</p> <p>Solo podr\u00e1s moverte a celdas adyacentes que no sean paredes y que est\u00e9n conectadas directamente a tu posici\u00f3n actual. Las celdas v\u00e1lidas se resaltar\u00e1n cuando coloques el cursor sobre ellas. El camino por el que ya te has movido se muestra en gris, y no podr\u00e1s volver a \u00e9l sin perder puntos.</p>"},{"location":"user_guide/how_to_play/#mecanicas-del-juego","title":"Mec\u00e1nicas del Juego","text":"<p>Antes de comenzar tu aventura, es crucial que comprendas las mec\u00e1nicas del juego. Aqu\u00ed te explicamos los elementos clave que debes dominar:</p>"},{"location":"user_guide/how_to_play/#caja-magica","title":"Caja M\u00e1gica","text":"<p>Tu objetivo principal es activar la Caja M\u00e1gica pasando por las celdas amarillas en el orden correcto. Solo al completar esta secuencia podr\u00e1s hacer visible la salida del laberinto.</p>"},{"location":"user_guide/how_to_play/#salida-oculta","title":"Salida Oculta","text":"<p>La salida del laberinto permanecer\u00e1 oculta hasta que completes la secuencia correcta de la Caja M\u00e1gica (la salida se muestra en color rosado fucsia).</p>"},{"location":"user_guide/how_to_play/#paredes-temporizadas","title":"Paredes Temporizadas","text":"<p>Las celdas azules se convertir\u00e1n en paredes despu\u00e9s de sobrepasar la cantidad de 30 turnos, bloqueando el acceso a ellas. Debes planificar tus movimientos para evitar quedarte atrapado.</p>"},{"location":"user_guide/how_to_play/#puntuacion-backtracking","title":"Puntuaci\u00f3n (Backtracking)","text":"<p>Comienzas con 1000 puntos. Cada vez que retrocedas por un camino ya recorrido (el camino ya recorrido se muestra en gris), perder\u00e1s 50 puntos. Si te quedas sin puntos o sin movimientos posibles, perder\u00e1s el juego.</p>"},{"location":"user_guide/how_to_play/#solver-automatico","title":"Solver Autom\u00e1tico","text":"<p>El solver autom\u00e1tico es una herramienta avanzada que te permite ver la soluci\u00f3n \u00f3ptima al laberinto. Al hacer clic en el bot\u00f3n \"Resolver\", el juego utilizar\u00e1 el algoritmo A* (puedes encontrar m\u00e1s informaci\u00f3n sobre este algoritmo en la secci\u00f3n de Algoritmos Implementados) para encontrar y mostrar la ruta m\u00e1s eficiente hacia la salida.</p> <p>El solver actua de dos maneras:</p> <ul> <li>Visualizaci\u00f3n de la Ruta: Muestra la ruta \u00f3ptima en el tablero, resaltando las celdas que debes seguir.</li> <li>Reproducci\u00f3n Autom\u00e1tica: Despu\u00e9s de mostrar la ruta \u00f3ptima, autom\u00e1ticamente reproduce los movimientos necesarios para completar el laberinto, permiti\u00e9ndote observar c\u00f3mo se resuelve el puzzle paso a paso.</li> </ul> <p>El Solver Autom\u00e1tico tiene conocimiento de la estructura del laberinto y sobre las reglas del juego, lo que le permite encontrar soluciones eficientes.</p> <p>Esta herramienta se puede ejecutar en diferentes casos:</p> <ul> <li>Al iniciar el juego: Para ver la soluci\u00f3n desde el principio.</li> <li>Despu\u00e9s de realizar algunos movimientos: Para obtener una soluci\u00f3n parcial basada en tu progreso actual. El Solver es consciente de los movimientos que has realizado y ajustar\u00e1 la soluci\u00f3n en consecuencia.</li> <li>Cuando no existe una ruta optima desde la posici\u00f3n actual: El solver al ser consiente de la situaci\u00f3n actual del juego te indicar\u00e1 que no hay una ruta posible desde tu posici\u00f3n actual posiblemente porque te quedar\u00e1s sin puntos en tus proximos movimientos (si es necesario hacer backtracking) o porque no hay una ruta posible desde tu posici\u00f3n actual (por si la ruta est\u00e1 bloqueada por los muros temporizados).</li> </ul>"},{"location":"user_guide/how_to_play/#informacion-adicional","title":"Informaci\u00f3n Adicional","text":"<ul> <li> <p>Para ver en acci\u00f3n todas las mec\u00e1nicas del juego, revisa la secci\u00f3n de Gu\u00eda Visual.</p> </li> <li> <p>Si deseas crear tus propios mapas personalizados, consulta la secci\u00f3n de Mapas Personalizados para aprender c\u00f3mo dise\u00f1ar laberintos \u00fanicos y desafiantes.</p> </li> </ul>"},{"location":"user_guide/visual_guide/","title":"Gu\u00eda Visual","text":"<p>En esta secci\u00f3n, te proporcionaremos una gu\u00eda visual que te ayudar\u00e1 a comprender mejor las mec\u00e1nicas del juego y c\u00f3mo interactuar con \u00e9l. A continuaci\u00f3n, encontrar\u00e1s una serie de im\u00e1genes o GIFs mostrando las diferentes partes del juego, desde la interfaz hasta las mec\u00e1nicas de la Caja M\u00e1gica y el solver autom\u00e1tico.</p>"},{"location":"user_guide/visual_guide/#interfaz-del-juego","title":"Interfaz del Juego","text":""},{"location":"user_guide/visual_guide/#mecanicas-del-juego","title":"Mec\u00e1nicas del Juego","text":""},{"location":"user_guide/visual_guide/#caja-magica","title":"Caja M\u00e1gica","text":"<p>La Caja M\u00e1gica es el elemento central del juego. Debes activar las celdas amarillas en el orden correcto para hacer visible la salida del laberinto.</p> <p></p>"},{"location":"user_guide/visual_guide/#paredes-temporizadas","title":"Paredes Temporizadas","text":"<p>Las celdas azules se convertir\u00e1n en muros impenetrables despu\u00e9s de 30 turnos. Debes planificar tus movimientos para evitar quedarte atrapado.</p> <p></p>"},{"location":"user_guide/visual_guide/#movimiento-y-backtracking","title":"Movimiento y Backtracking","text":"<p>El movimiento se realiza haciendo clic en las celdas adyacentes. Si retrocedes por un camino ya recorrido, perder\u00e1s puntos.</p> <p></p>"},{"location":"user_guide/visual_guide/#solver-automatico","title":"Solver Autom\u00e1tico","text":"<p>El solver autom\u00e1tico te ayudar\u00e1 a encontrar la ruta \u00f3ptima hacia la salida. Puedes activarlo desde el panel lateral derecho del juego.</p> <ul> <li>Desde el inicio del juego:</li> </ul> <p></p> <ul> <li>Despu\u00e9s de realizar algunos movimientos:</li> </ul> <p></p> <ul> <li>Al no encontrar una ruta \u00f3ptima:</li> </ul> <p></p>"},{"location":"user_guide/setup_libs/cmake/","title":"CMake","text":""},{"location":"user_guide/setup_libs/cmake/#guia-para-descarga-e-instalacion-de-cmake","title":"Gu\u00eda para Descarga e Instalaci\u00f3n de CMake","text":"<p>En esta secci\u00f3n, se detallan los pasos para descargar e instalar CMake, una herramienta esencial para la compilaci\u00f3n del proyecto \"Escape the Grid\". CMake es un sistema de automatizaci\u00f3n de compilaci\u00f3n que utiliza archivos de configuraci\u00f3n para generar archivos de proyecto espec\u00edficos del entorno de desarrollo.</p>"},{"location":"user_guide/setup_libs/cmake/#instalacion-en-windows","title":"Instalaci\u00f3n en Windows","text":""},{"location":"user_guide/setup_libs/cmake/#descargar-el-instalador-de-cmake","title":"Descargar el instalador de CMake","text":"<ol> <li> <p>Visita la p\u00e1gina oficial de CMake y descarga el instalador para Windows. Aseg\u00farate de seleccionar la versi\u00f3n adecuada para tu sistema operativo (32-bit o 64-bit).</p> <p></p> </li> <li> <p>Una vez descargado, ejecuta el instalador.</p> </li> <li> <p>Presiona \"Next\" en la pantalla de bienvenida del instalador.</p> </li> <li> <p>Presiona \"I Agree\" para aceptar los t\u00e9rminos de la licencia.</p> </li> </ol>"},{"location":"user_guide/setup_libs/cmake/#agregar-cmake-al-path","title":"Agregar CMake al PATH","text":"<ol> <li> <p>Durante la instalaci\u00f3n, aseg\u00farate de seleccionar la opci\u00f3n \"Add CMake to the system PATH for all users\" para que CMake est\u00e9 disponible desde cualquier terminal.</p> <p></p> <p>Esta imagen es ilustrativa solo para mostrar la opci\u00f3n de agregar CMake al PATH. El aspecto visual puede variar seg\u00fan la versi\u00f3n del instalador.</p> <p>Importante</p> <p>Si no seleccionas esta opci\u00f3n, tendr\u00e1s que agregar manualmente la ruta de CMake a las variables de entorno del sistema.</p> </li> <li> <p>Completa la instalaci\u00f3n haciendo clic en \"Install\" y luego en \"Finish\" cuando se complete el proceso.</p> </li> </ol>"},{"location":"user_guide/setup_libs/cmake/#verificar-la-instalacion","title":"Verificar la instalaci\u00f3n","text":"<ol> <li> <p>Abre una terminal y escribe el siguiente comando para verificar que CMake se ha instalado correctamente:</p> <pre><code>cmake --version\n</code></pre> <p>Informaci\u00f3n</p> <p>Si ves la versi\u00f3n de CMake, significa que la instalaci\u00f3n fue exitosa y CMake est\u00e1 correctamente configurado en tu sistema.</p> </li> </ol>"},{"location":"user_guide/setup_libs/cmake/#otros-sistemas-operativos","title":"Otros Sistemas Operativos","text":"<p>Para otros sistemas operativos, como macOS o Linux, puedes instalar CMake utilizando el gestor de paquetes correspondiente:</p> <ul> <li> <p>En macOS, puedes usar Homebrew: <pre><code>brew install cmake\n</code></pre></p> </li> <li> <p>En Ubuntu o Debian, puedes usar APT: <pre><code>sudo apt-get install cmake\n</code></pre></p> </li> </ul> <p>\u00a1Instalaci\u00f3n exitosa!</p> <p>Ahora tienes CMake instalado y configurado en tu sistema, listo para ser utilizado.</p>"},{"location":"user_guide/setup_libs/compiler_cpp/","title":"Compilador de C++17","text":""},{"location":"user_guide/setup_libs/compiler_cpp/#guia-para-configuracion-e-instalacion-del-compilador-c","title":"Gu\u00eda para Configuraci\u00f3n e Instalaci\u00f3n del Compilador C++","text":"<p>En este apartado se detallan los pasos necesarios para configurar un compilador C++ adecuado para el desarrollo del juego \"Escape the Grid\". Es esencial contar con un compilador compatible con las bibliotecas y herramientas utilizadas en el proyecto, especialmente SFML 3.0.0.</p>"},{"location":"user_guide/setup_libs/compiler_cpp/#instalacion-en-windows","title":"Instalaci\u00f3n en Windows","text":""},{"location":"user_guide/setup_libs/compiler_cpp/#descargar-desde-la-documentacion-de-sfml-300","title":"Descargar desde la documentaci\u00f3n de SFML 3.0.0","text":"<ol> <li>Visita la p\u00e1gina oficial de SFML 3.0.0 y descarga la versi\u00f3n <code>WinLibs UCRT 14.2.0</code> (asegurate de que sea la versi\u00f3n correcta para tu sistema operativo, ya sea 32-bit o 64-bit).</li> </ol> <p>La descarga te proporcionar\u00e1 un archivo comprimido <code>.zip</code> que contiene los archivos necesarios para el compilador C++.</p> <p>\u00bfPor qu\u00e9 es necesario instalar estos compiladores espec\u00edficos de C++ para SFML?</p> <p>SFML est\u00e1 distribuido en versiones precompiladas que fueron construidas usando compiladores muy espec\u00edficos (por ejemplo, WinLibs UCRT 14.2.0).  </p> <p>Si intentas compilar tu proyecto con una versi\u00f3n diferente de MinGW o GCC, aunque el n\u00famero de versi\u00f3n parezca coincidir, pueden existir diferencias internas que provoquen errores de enlace, incompatibilidades o fallos en tiempo de ejecuci\u00f3n.  </p> <p>Por eso, debes instalar exactamente el mismo compilador que se indica en la p\u00e1gina de descargas de SFML para garantizar que tu proyecto funcione correctamente y evitar problemas dif\u00edciles de diagnosticar.</p>"},{"location":"user_guide/setup_libs/compiler_cpp/#descomprimir-el-archivo-descargado","title":"Descomprimir el archivo descargado","text":"<ol> <li> <p>Crea una carpeta en el disco local <code>C:\\&lt;nombre_de_carpeta&gt;</code> (esta ubicaci\u00f3n es recomendada, pero puedes elegir otra ruta si lo prefieres).</p> </li> <li> <p>Copia el archivo <code>.zip</code> descargado en la carpeta creada.</p> </li> <li> <p>Extrae el contenido del archivo <code>.zip</code> descargado. El resultado de la extracci\u00f3n deber\u00eda ser como se muestra a continuaci\u00f3n:</p> <p></p> </li> </ol>"},{"location":"user_guide/setup_libs/compiler_cpp/#configuracion-de-variables-de-entorno","title":"Configuraci\u00f3n de Variables de Entorno","text":"<ol> <li> <p>Dentro de la carpeta <code>mingw64</code> (que extrajiste en el paso anterior), localiza la carpeta <code>bin</code> que contiene los archivos ejecutables del compilador e ingresa a ella.</p> <p></p> </li> <li> <p>Copia la ruta absoluta desde la carpeta <code>bin</code>.</p> <p>Info</p> <p>La ruta deber\u00eda ser algo como <code>C:\\&lt;nombre_de_carpeta&gt;\\mingw64\\bin</code> si seguiste la ubicaci\u00f3n de ruta recomendada.</p> </li> <li> <p>Presiona la tecla <code>Windows</code> y en la barra de b\u00fasqueda escribe \"Variables de entorno\", luego selecciona la opci\u00f3n tal como se muestra en la imagen:</p> <p></p> </li> <li> <p>En la ventana de \"Propiedades del sistema\", haz clic en el bot\u00f3n \"Variables de entorno\".</p> <p></p> </li> <li> <p>En la ventana \"Variables de entorno\" y en la secci\u00f3n \"Variables del sistema\", busca la variable llamada <code>Path</code> y selecci\u00f3nala. Luego haz clic en \"Editar\".</p> <p></p> </li> <li> <p>En la ventana \"Editar variable de entorno\", haz clic en \"Nuevo\" y pega la ruta absoluta que copiaste en el paso 2. </p> <p></p> </li> <li> <p>Luego haz clic en \"Aceptar\" para cerrar todas las ventanas.</p> </li> <li> <p>Para verificar que la configuraci\u00f3n se realiz\u00f3 correctamente, abre una nueva ventana de terminal y ejecuta el comando el siguiente comando:</p> <pre><code>g++ --version\n</code></pre> <p>Si la instalaci\u00f3n y configuraci\u00f3n fueron exitosas, deber\u00edas ver la versi\u00f3n del compilador C++ instalada.</p> </li> </ol>"},{"location":"user_guide/setup_libs/compiler_cpp/#instalacion-en-macos","title":"Instalaci\u00f3n en MacOS","text":""},{"location":"user_guide/setup_libs/compiler_cpp/#xcode-para-compilacion-de-c","title":"Xcode para Compilaci\u00f3n de C++","text":"<p>Para compilar C++ en macOS, es necesario instalar las herramientas de desarrollo de Xcode, que incluyen el compilador <code>clang</code> y otras utilidades necesarias. A continuaci\u00f3n se detallan los pasos para instalar el compilador C++ en macOS:</p> <ol> <li> <p>Instalar las herramientas de desarrollo de Xcode</p> <pre><code>xcode-select --install\n</code></pre> <p>Esto instalar\u00e1 los compiladores y utilidades b\u00e1sicas necesarias para el desarrollo en C/C++ en macOS.</p> </li> </ol> <p>\u00a1Instalaci\u00f3n exitosa!</p> <p>Ahora tienes un compilador C++ compatible con SFML 3.0.0 instalado y configurado en tu sistema, listo para ser utilizado.</p>"},{"location":"user_guide/setup_libs/sfml/","title":"SFML 3.0.0","text":""},{"location":"user_guide/setup_libs/sfml/#guia-para-descarga-de-sfml-300","title":"Gu\u00eda para Descarga de SFML 3.0.0","text":"<p>En esta secci\u00f3n, se detallan los pasos para descargar SFML 3.0.0, que es esencial para el desarrollo del juego \"Escape the Grid\". SFML es una biblioteca multimedia que proporciona herramientas para manejar gr\u00e1ficos, sonido y entrada de usuario de manera eficiente.</p> <p>Los modulos de SFML utilizados en este proyecto son:</p> <ul> <li>Graphics: Para renderizar gr\u00e1ficos en 2D.</li> <li>Window: Para manejar ventanas y eventos de entrada.</li> <li>System: Para manejar el sistema y las operaciones b\u00e1sicas.</li> </ul>"},{"location":"user_guide/setup_libs/sfml/#instalacion-en-windows","title":"Instalaci\u00f3n en Windows","text":""},{"location":"user_guide/setup_libs/sfml/#descargar-sfml-300","title":"Descargar SFML 3.0.0","text":"<ol> <li>Visita la p\u00e1gina oficial de SFML 3.0.0 y descarga la versi\u00f3n <code>GCC 14.2.0 MinGW (SEH) (UCRT)</code> (aseg\u00farate de que sea la versi\u00f3n correcta para tu sistema operativo, ya sea 32-bit o 64-bit) para Windows como se muestra en la imagen:</li> </ol> <p>La descarga te proporcionar\u00e1 un archivo comprimido <code>.zip</code> que contiene los archivos necesarios para utilizar SFML en tu proyecto.</p>"},{"location":"user_guide/setup_libs/sfml/#extraer-los-archivos","title":"Extraer los archivos","text":"<ol> <li> <p>Crea una carpeta en el disco local <code>C:\\&lt;nombre_de_carpeta&gt;</code> (esta ubicaci\u00f3n es recomendada, pero puedes elegir otra ruta si lo prefieres).</p> </li> <li> <p>Copia el archivo <code>.zip</code> descargado en la carpeta creada.</p> </li> <li> <p>Extrae el contenido del archivo <code>.zip</code> descargado. El resultado de la extracci\u00f3n deber\u00eda ser como se muestra a continuaci\u00f3n:</p> <p></p> <p>Informaci\u00f3n</p> <p>Por el momento, no es necesario mover la carpeta <code>SFML-3.0.0</code> a otra ubicaci\u00f3n, ya que el proyecto se configurar\u00e1 para utilizarla directamente desde su ubicaci\u00f3n actual. En la secci\u00f3n \"Instrucciones de Compilaci\u00f3n\", se explicar\u00e1 c\u00f3mo configurar el proyecto para que utilice esta carpeta y sus archivos necesarios.</p> </li> </ol>"},{"location":"user_guide/setup_libs/sfml/#instalacion-en-macos","title":"Instalaci\u00f3n en MacOS","text":""},{"location":"user_guide/setup_libs/sfml/#descargar-utilizando-homebrew","title":"Descargar Utilizando Homebrew","text":"<ul> <li>Abre una terminal y utiliza Homebrew para instalar SFML ejecutando el siguiente comando:</li> </ul> <pre><code>brew install sfml@3.0.0\n</code></pre>"},{"location":"user_guide/setup_libs/sfml/#descarga-manual","title":"Descarga Manual","text":"<ul> <li>Tambi\u00e9n, puedes descargar SFML 3.0.0 desde la documentaci\u00f3n oficial de SFML 3.0.0 y seguir las instrucciones de instalaci\u00f3n manual.</li> </ul>"},{"location":"user_guide/setup_libs/sfml/#otros-sistemas-operativos","title":"Otros Sistemas Operativos","text":"<ul> <li>Para otros sistemas operativos, consulta la documentaci\u00f3n oficial de SFML 3.0.0 para obtener instrucciones espec\u00edficas de instalaci\u00f3n.</li> </ul> <p>\u00a1Instalaci\u00f3n exitosa!</p> <p>Ahora tienes SFML 3.0.0 listo para usarse.</p>"}]}